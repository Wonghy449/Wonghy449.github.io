---
title: 设计模式
date: 2017-03-07 13:25:24
categories: 设计模式
tags: [设计模式]
comments: true
toc: true
---

[TOC]

# 一、设计模式的六大原则

### 总原则：开闭原则（Open Close Principle）

开闭原则就是说**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。

### 1、单一职责原则

不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。

### 2、里氏替换原则（Liskov Substitution Principle）

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

### 3、依赖倒转原则（Dependence Inversion Principle）

这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。（**抽象不应该依赖细节，细节应该依赖于抽象**）

### 4、接口隔离原则（Interface Segregation Principle）

这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

### 5、迪米特法则（最少知道原则）（Demeter Principle）

就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

### 6、合成复用原则（Composite Reuse Principle）

原则是尽量首先使用合成/聚合的方式，而不是使用继承。

使用“Has-A”和“Is-A”来判断:

“Is－A”代表一个类是另外一个类的一种，可以使用继承关系，而“Has-A”代表一个类是另外一个类的一个角色，而不是另外一个类的特殊种类。

# 二、设计模式分类

Java中设计模式（java design patterns）通常有23种。模式可以分成3类：创建型、行为型和结构型。

## 创建型模式

创建型模式涉及对象的实例化，特点是不让用户代码依赖于对象的创建或者排列方式，避免用户直接使用new创建对象。

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

### 1、单例模式

单例对象能保证在一个JVM中，该对象只有一个实例存在。好处在于：

- 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。

- 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。

- 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。

#### 饿汉式单例类

```java
public class EagerSingleton {
    //饿汉单例模式
    //在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快
    private static EagerSingleton instance = new EagerSingleton();
    /**
     * 私有默认构造子
     */
    private EagerSingleton(){}
    /**
     * 静态工厂方法
     * 静态，不用同步（类加载时已初始化，不会有多线程的问题）
     */
    public static EagerSingleton getInstance(){
        return instance;
    }
}
```

**饿汉式是典型的空间换时间**，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。

所以饿汉式是**线程安全**的

#### 懒汉式单例类

```java
public class LazySingleton {
    //懒汉式单例模式
    //比较懒，在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢
    //静态私用成员，没有初始化
    private static LazySingleton instance = null;
    /**
     * 私有默认构造子
     */
    private LazySingleton(){}
    /**
     * 静态工厂方法
     * 同步保证多线程时的正确性（因为类变量不是在加载时初始化的）
     */
    public static synchronized LazySingleton getInstance(){
        if(instance == null){
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

**懒汉式是典型的时间换空间**,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。

由于懒汉式的实现是涉及到线程安全的问题，所以一般会使用关键字synchronized来实现线程安全，这样会降低整个访问的速度，而且每次都要判断。

### 2、简单工厂方法模式

![](https://note.youdao.com/yws/api/personal/file/B629A5676A8A4C939E9981354AF73C0B?method=download&shareKey=13825c1a0b1b0f882b67565e9a999be7)

简单工厂模式实现了**生成产品类的代码跟客户端代码分离**，在工厂类中你可以添加所需的生成产品的逻辑代码，但是问题来了，优秀的java代码是符合“开放-封闭”原则的，也就是说对扩展开发，对修改关闭，如果你要加一个产品类C，你就要修改工厂类里面的生成产品的代码，在这里你就要增加if-else判断。**严重违反了开闭原则**

```java
public interface Product {
    //声明类所需继承的共同接口，也可以是抽象类
}

public class ProductA implements Product {
    public ProductA() {
        System.out.println("ProductA");
    }
}
public class ProductB implements Product{}
//工厂类
public class Factory {
    //可以在工厂类中添加任何你所需要的逻辑
    public static Product create(String str)
    {
        //生成ProductA
        if(str.equalsIgnoreCase("ProductA"))
        {
            return new ProductA();
        }
        else
            //生成ProductB
            if(str.equalsIgnoreCase("ProductB"))
            {
                return new ProductB();
            }
        return null;
    }
}
//客户端
public class Client {
    public static void main(String[] args) {
        //调用Factory的静态方法生成所要的类
        Factory.create("productA");
        Factory.create("ProductB");
    }
}
```

### 3、抽象工厂方法模式

**工厂模式 与 抽象工厂模式的区别：**

> 工厂方法模式：
> 一个抽象产品类，可以派生出多个具体产品类。
> 一个抽象工厂类，可以派生出多个具体工厂类。
> 每个具体工厂类只能创建一个具体产品类的实例。
>
> 抽象工厂模式：(**多个产品线，你想换什么产品配置，直接建一个工厂就行了**)
> 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 
> 一个抽象工厂类，可以派生出多个具体工厂类。 
> 每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品

**类图：**

![](https://note.youdao.com/yws/api/personal/file/1390851141E544C3B5136ADDBD5E7EFA?method=download&shareKey=854d389c2d7d3286a9ee2968aed11fdc)

**抽象工厂有个弊端：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的工厂里加代码，又要在具体的里面加代码。

可以使用反射+配置文件来解决抽象工厂方法中更换数据库替换的方案

```java
public class DataAccess {
    public  String getDb(){
        Properties prop = new Properties();
        String db = "";
        try {
            InputStream in = DataAccess.class.getClassLoader().getResourceAsStream("sql.properties");
            prop.load(in);
            db = prop.getProperty("db");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return db;
    }
	//反射到对应的Class
    public Class<?> getSqlFactory(String name) throws ClassNotFoundException {
        String className = "com.hhy.algorithm.designPattern.AbstractFactory."+getDb()+name;
        System.out.println(className);
        Class<?> c1 = Class.forName(className);
        System.out.println(c1.getName());
        return c1;
    }
    
    public IUser CreateUser() throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        Class<?> c1 = getSqlFactory("User");
        //获取实例
        OracleUser oracleUser = (OracleUser) c1.newInstance();
        return oracleUser;
    }
}
```




### 4、原型模式

**原理**：用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象。该模式不用重新初始化对象，而是动态地获取对象运行时的状态

**类图**：

![](https://note.youdao.com/yws/api/personal/file/561C0D4AB0E04F4693AAF316CAFC7704?method=download&shareKey=e77ec8be4bafa434a0ff168731b143cf)

**深复制与浅复制**：

浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象

深复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。

```java
public class Prototype implements Cloneable,Serializable {

    private String name;

    private User user;
    /**
     * 浅复制
     * 如果字段是值类型，对该字段执行逐位复制；如果字段是引用类型，则复制引用但不复制引用的对象
     * 因此，原始对象跟它副本都是引用同一个对象
     * @return
     * @throws CloneNotSupportedException
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Prototype proto = (Prototype) super.clone();
        return proto;
    }

    /**
     * 深复制
     * 所有需要复制的对象都需要实现java.io.Serializable接口。
     * 对象被序列化，然后又被反序列化。反序列化的对象就成了一个深克隆的结果
     * @return
     * @throws IOException
     * @throws ClassNotFoundException
     */
    public Object deepClone() throws IOException, ClassNotFoundException {
        /* 写入当前对象的二进制流 */
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        /* 读出二进制流产生的新对象 */
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return ois.readObject();
    }
}
```

**原型模式的优缺点**：

优点：原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。

缺点：原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。

### 5、建造者模式（生成器模式）

**原理**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。所以当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时使用的模式

**类图**：

![](https://note.youdao.com/yws/api/personal/file/4934149B8C4D416BB56CB04F70D433BF?method=download&shareKey=abacae4ce0274748ab1cec292304ef88)

**抽象建造者（Builder）角色：**给 出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是**建造方法(buildPart1和 buildPart2)**，另一种是**返还结构方法(retrieveResult)**。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，<u>有多少零件，就有多少相应的建造方法</u>。

**具体建造者（ConcreteBuilder）角色：**担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。这个角色要完成的任务包括：1.实现抽象建造者Builder所声明的接口，给出一步一步地完成创建产品实例的操作。2.在建造过程完成后，提供产品的实例。

**导演者（Director）角色：**担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。

**产品（Product）角色：**产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。

*一般来说，每有一个产品类，就有一个相应的具体建造者类。这些产品应当有一样数目的零件，而每有一个零件就相应地在所有的建造者角色里有一个建造方法。*

```java
//具体建造者
public class ConcreteBuilder implements Builder {
    private Product product = new Product();
    /**
     * 产品零件建造方法1
     */
    @Override
    public void buildPart1() {
        //构建产品的第一个零件
 　　　　product.setPart1("编号：9527");
    }
    /**
     * 产品零件建造方法2
     */
    @Override
    public void buildPart2() {
        //构建产品的第二个零件
 　　　　product.setPart2("名称：XXX");
    }
    /**
     * 产品返还方法
     */
    @Override
    public Product retrieveResult() {
        return product;
    }
}
//导演类
public class Director {
    /**
     * 持有当前需要使用的建造器对象
     */
    private Builder builder;
    /**
     * 构造方法，传入建造器对象
     * @param builder 建造器对象
     */
    public Director(Builder builder){
        this.builder = builder;
    }
    /**
     * 产品构造方法，负责调用各个零件建造方法
     */
    public void construct(){
        builder.buildPart1();
        builder.buildPart2();
    }
}
```

## 行为型模式

通过行为型模式，可以更加清晰地划分类与对象的职责，描述类或对象怎样**进行交互和职责分配**。并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

### 1、策略模式

### 2、模板方法模式

### 3、观察者模式

### 4、迭代子模式

### 5、责任链模式

### 6、命令模式

### 7、备忘录模式

### 8、状态模式

### 9、访问者模式

### 10、中介者模式

### 11、解释器模式

## 结构型模式

处理类或对象间的组合。它将以不同的方式影响着程序，允许在补充写代码或自定义代码的情况下创建系统，而且具有重复使用性和应用性能

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

![](http://dl.iteye.com/upload/attachment/0083/1187/e28698b9-994e-3fa8-8810-16f30e7cf3e3.jpg)

### 1、适配器模式

### 2、装饰器模式



### 3、代理模式

### 4、外观模式

### 5、桥接模式

### 6、组合模式

### 7、享元模式