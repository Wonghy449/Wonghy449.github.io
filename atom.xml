<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-18T07:07:35.567Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Huayan Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/06/18/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E4%B8%80%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/06/18/Java编程思想一：对象导论/</id>
    <published>2019-06-18T03:38:36.543Z</published>
    <updated>2019-04-18T07:07:35.567Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h1 id="纯粹的面向对象程序设计方式"><a href="#纯粹的面向对象程序设计方式" class="headerlink" title="纯粹的面向对象程序设计方式"></a>纯粹的面向对象程序设计方式</h1><ol><li><h2 id="万物皆为对象"><a href="#万物皆为对象" class="headerlink" title="万物皆为对象"></a>万物皆为对象</h2></li><li><p>程序是对象的集合，他们通过发送消息来告诉彼此所要做的</p></li><li><p>每个对象都有自己的有其他对象所构成的存储</p></li><li><p>每个对象都有用其类型</p></li><li><p>某一特定的所有对象都可以接受同样的消息</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;纯粹的面向对象程序设计方式&quot;&gt;&lt;a href=&quot;#纯粹的面向对象程序设计方式&quot; class=&quot;headerlink&quot; title=&quot;纯
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot日志</title>
    <link href="http://yoursite.com/2019/04/15/2018-7-5-SpringBoot%E4%B9%8B%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2019/04/15/2018-7-5-SpringBoot之日志/</id>
    <published>2019-04-15T03:46:00.292Z</published>
    <updated>2019-04-15T03:49:23.139Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之注解类</title>
    <link href="http://yoursite.com/2019/04/15/2018-7-2-SpringBoot%E4%B9%8B%E6%B3%A8%E8%A7%A3%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/04/15/2018-7-2-SpringBoot之注解类/</id>
    <published>2019-04-15T03:46:00.286Z</published>
    <updated>2019-04-15T03:49:23.093Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h4 id="1、-ConfigurationProperties和-Value的区别"><a href="#1、-ConfigurationProperties和-Value的区别" class="headerlink" title="1、@ConfigurationProperties和@Value的区别"></a>1、@ConfigurationProperties和@Value的区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "author")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;bean class="User"&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="name" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取/#&#123;spEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>@Value用法：等同于上面的<property>中的value赋值</property></p><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">@ConfigurationProperties</th><th style="text-align:center">@Value</th></tr></thead><tbody><tr><td style="text-align:center">功能</td><td style="text-align:center">批量注入配置文件中的属性</td><td style="text-align:center">一个个指定</td></tr><tr><td style="text-align:center">松散绑定（松散语法）</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">SpEL</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">JSR303数据校验（@Email等）</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr></tbody></table><p>如果说，只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value<br>如果说，专门编写一个javaBean来和配置文件进行映射，使用@ConfigurationProperties</p><h4 id="2、-PropertySource-amp-ImportSource"><a href="#2、-PropertySource-amp-ImportSource" class="headerlink" title="2、@PropertySource&amp;@ImportSource"></a>2、@PropertySource&amp;@ImportSource</h4><p>@PropertySource:加载指定的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "author")</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br></pre></td></tr></table></figure><p>@ImportSource：导入Spring的配置文件，让配置文件里面的内容生效</p><p>在Spring Boot中，对于我们自己编写的配置文件，是不能自动识别的；</p><p>想让Spring的配置文件生效，加载进去；需要将<strong>@ImportSource</strong>加载配置类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportSource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure><p>SpringBoot推荐给容器中添加组件的方式：推荐全注解<br>1、配置类，使用@Configuration设置为配置类<br>2、使用@Bean给容器添加组件<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将方法中的返回值添加到容器中，容器中这种组件的id为方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloServiceImpl <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>3、</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;1、-ConfigurationProperties和-Value的区别&quot;&gt;&lt;a href=&quot;#1、-ConfigurationPro
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之配置文件</title>
    <link href="http://yoursite.com/2019/04/15/2018-7-2-SpringBoot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/04/15/2018-7-2-SpringBoot之配置文件/</id>
    <published>2019-04-15T03:46:00.279Z</published>
    <updated>2019-04-15T03:49:23.264Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h4 id="1、YAML语法："><a href="#1、YAML语法：" class="headerlink" title="1、YAML语法："></a><strong>1、YAML语法：</strong></h4><h4 id="2、配置文件值注入"><a href="#2、配置文件值注入" class="headerlink" title="2、配置文件值注入"></a><strong>2、配置文件值注入</strong></h4><h4 id="3、配置文件占位符"><a href="#3、配置文件占位符" class="headerlink" title="3、配置文件占位符"></a><strong>3、配置文件占位符</strong></h4><h5 id="1、随机数"><a href="#1、随机数" class="headerlink" title="1、随机数"></a>1、随机数</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;</span><br><span class="line">$&#123;random.int(10)&#125;、$random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure><h5 id="2、占位符获取前面配置的值，如果没有可以用-（冒号）-指定默认值"><a href="#2、占位符获取前面配置的值，如果没有可以用-（冒号）-指定默认值" class="headerlink" title="2、占位符获取前面配置的值，如果没有可以用 :（冒号） 指定默认值"></a>2、占位符获取前面配置的值，如果没有可以用 :（冒号） 指定默认值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.lastName=hhy</span><br><span class="line">person.dog.name=$&#123;person.hello:hello&#125;_dog</span><br></pre></td></tr></table></figure><h4 id="4、Profile多环境配置"><a href="#4、Profile多环境配置" class="headerlink" title="4、Profile多环境配置"></a>4、Profile多环境配置</h4><h5 id="1、多Profile文件"><a href="#1、多Profile文件" class="headerlink" title="1、多Profile文件"></a>1、多Profile文件</h5><p>application-{profile}.properties/yml</p><p>默认使用application.properties文件</p><h5 id="2、yml支持多文档块方式"><a href="#2、yml支持多文档块方式" class="headerlink" title="2、yml支持多文档块方式"></a>2、yml支持多文档块方式</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8083</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8084</span></span><br></pre></td></tr></table></figure><h5 id="3、激活使用profile"><a href="#3、激活使用profile" class="headerlink" title="3、激活使用profile"></a>3、激活使用profile</h5><p>​ 1、在配置文件中指定 spring.profiles.active=dev</p><p>​ 2、命令行：–spring.profiles.active=dev</p><p>​ 在run/debug Confgurations中Program arguments中填写–spring.profiles.active=dev</p><p>​ 在cmd中，java -jar xxxx.jar –spring.profiles.active=dev</p><p>​ 3、虚拟机参数：</p><p>​ 在run/debug Confgurations中VM options中填写:</p><p>​ -Dspring.profiles.active=dev</p><h4 id="5、配置文件加载位置"><a href="#5、配置文件加载位置" class="headerlink" title="5、配置文件加载位置"></a>5、配置文件加载位置</h4><p>Spring boot启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><p>file: ./config/ 根路径的文件夹</p><p>file: ./</p><p>classpath: ./config/ 类路径的config文件夹</p><p>classpath: /</p><p>优先级由高到低，高优先级的配置会覆盖低优先级的配置</p><p>Spring boot 会从四个位置全部加载主配置文件：<strong>互补配置</strong></p><p>在运维的时候比较方便：</p><p>可以通过<strong>spring.config.location</strong>来改变配置</p><p>项目已经打包好了，我可以使用<strong>命令行参数</strong>的形式（–spring.config.location=xxxx），启动项目的时候指定配置文件的新位置；指定配置文件和默认加载的配置文件共同起作用形成<strong>互补配置</strong></p><h4 id="6、外部配置加载顺序"><a href="#6、外部配置加载顺序" class="headerlink" title="6、外部配置加载顺序"></a>6、外部配置加载顺序</h4><p><strong>优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p><p><strong>1.命令行参数</strong><br>所有的配置都可以在命令行上进行指定<br>java -jar xxx.jar –server.port=8087 –server.context-path=/abc<br>多个配置用空格分开 –配置项=值<br>2.来自java:comp/env的JNDI属性<br>3.Java系统属性（System.getProperties()）<br>4.操作系统环境变量<br>5.RandomValuePropertySource配置的random.*属性值</p><p>由<strong>jar包外向jar包内</strong>进行寻找；</p><p>==<strong>优先加载带profile</strong>==<br><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong><br><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p>==<strong>再来加载不带profile</strong>==<br><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong><br><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource<br>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；<br><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><h4 id="7、自动配置原理"><a href="#7、自动配置原理" class="headerlink" title="7、自动配置原理"></a>7、自动配置原理</h4><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><ol><li>Spring Boot 启动的时候加载主配置类，开启自动配置功能==@EnableAutoConfiguration==</li><li>==@EnableAutoConfiguration==的作用：</li></ol><p>精髓：</p><p>xxxAutoConfiguration：自动配置类</p><p>给容器添加组件</p><p>xxxProperties：<strong>封装</strong>配置文件中相关属性（如果我们对自动配置类中哪些属性 不满意，可以通过在配置文件中配置）</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;1、YAML语法：&quot;&gt;&lt;a href=&quot;#1、YAML语法：&quot; class=&quot;headerlink&quot; title=&quot;1、YAML语法：
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之基础准备</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-14-SpringBoot%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-14-SpringBoot基础准备/</id>
    <published>2019-04-15T03:46:00.266Z</published>
    <updated>2019-04-15T03:49:23.239Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h2 id="SpringBoot是什么？"><a href="#SpringBoot是什么？" class="headerlink" title="SpringBoot是什么？"></a>SpringBoot是什么？</h2><ul><li>简化Spring应用开发的一个框架；</li><li>整个Spring技术栈的大集合；</li><li>J2EEE开发的一站式解决方案<h2 id="SpringBoot优缺点？"><a href="#SpringBoot优缺点？" class="headerlink" title="SpringBoot优缺点？"></a>SpringBoot优缺点？</h2></li><li>快速创建独立运行的Spring项目和主流框架的继承</li><li>使用嵌入式的Servlet容器，应用无需打包成war包，直接打包成jar包，使用java -jar命令执行</li><li>starters自动依赖与版本控制</li><li>大量自动配置，简化开发，也可修改默认值</li><li>无需配置xml</li><li>生产环境的运行时应用监控</li><li>与云计算的天然合成</li></ul><h2 id="SpringApplication的执行流程"><a href="#SpringApplication的执行流程" class="headerlink" title="SpringApplication的执行流程"></a>SpringApplication的执行流程</h2><p><strong>流程图：</strong><br><img src="https://note.youdao.com/yws/api/personal/file/F8240B8EF72E4749A998B6A085C8490D?method=download&amp;shareKey=7f2f78e525977804bf8fd2b690929c8e" alt="image"></p><p><strong>具体步骤：</strong></p><ol><li>SpringApplication初始化</li><li></li></ol><p>SpringApplicationRunListener</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;SpringBoot是什么？&quot;&gt;&lt;a href=&quot;#SpringBoot是什么？&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>缓存机制</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-07-%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-07-缓存/</id>
    <published>2019-04-15T03:46:00.256Z</published>
    <updated>2019-04-15T03:49:23.069Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h2 id="缓存是什么？"><a href="#缓存是什么？" class="headerlink" title="缓存是什么？"></a>缓存是什么？</h2><h2 id="MyBatis缓存问题："><a href="#MyBatis缓存问题：" class="headerlink" title="MyBatis缓存问题："></a>MyBatis缓存问题：</h2><p>useCache和flushCache这两个选项有点混淆：</p><p>flushCache：如果设成true，当语句调用时一级二级缓存都会被清理掉。select语句默认是false<br>useCache：如果设成true，语句调用的结果会缓存在二级缓存里。select语句默认是true</p><h2 id="第三方缓存："><a href="#第三方缓存：" class="headerlink" title="第三方缓存："></a>第三方缓存：</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;缓存是什么？&quot;&gt;&lt;a href=&quot;#缓存是什么？&quot; class=&quot;headerlink&quot; title=&quot;缓存是什么？&quot;&gt;&lt;/a&gt;缓存是
      
    
    </summary>
    
      <category term="缓存" scheme="http://yoursite.com/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Git远程仓库</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-06-git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-06-git远程仓库/</id>
    <published>2019-04-15T03:46:00.248Z</published>
    <updated>2019-04-15T03:49:23.217Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><p>用命令行形式来创建一个仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echo "# MyDemo" &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line">git commit -m "first commit"</span><br><span class="line"></span><br><span class="line">git remote add origin https://github.com/Wonghy449/MyDemo.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>从已有的远程仓库克隆一份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:Wonghy449/MyDemo.git</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;用命令行形式来创建一个仓库&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-06-git%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-06-git命令列表/</id>
    <published>2019-04-15T03:46:00.241Z</published>
    <updated>2019-04-15T03:49:23.116Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h2 id="Git的操作"><a href="#Git的操作" class="headerlink" title="Git的操作"></a>Git的操作</h2><p>参考：<a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#diff" target="_blank" rel="noopener">图解Git命令</a></p><p><strong>日常使用6个命令</strong><br><img src="https://images2017.cnblogs.com/blog/63651/201709/63651-20170905212837976-775285128.png" alt="image"></p><h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下，也可以在项目目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line">#查看系统config</span><br><span class="line">git config --system --list</span><br><span class="line">　　</span><br><span class="line">#查看当前用户（global）配置</span><br><span class="line">git config --global  --list</span><br><span class="line"> </span><br><span class="line">#查看当前仓库配置信息</span><br><span class="line">git config --local  --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 列出所有本地分支</span><br><span class="line"><span class="meta">$</span> git branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 列出所有远程分支</span><br><span class="line"><span class="meta">$</span> git branch -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 列出所有本地分支和远程分支</span><br><span class="line"><span class="meta">$</span> git branch -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新建一个分支，但依然停留在当前分支</span><br><span class="line"><span class="meta">$</span> git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新建一个分支，并切换到该分支</span><br><span class="line"><span class="meta">$</span> git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新建一个分支，指向指定commit</span><br><span class="line"><span class="meta">$</span> git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line"><span class="meta">$</span> git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 切换到指定分支，并更新工作区</span><br><span class="line"><span class="meta">$</span> git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line"><span class="meta">$</span> git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 合并指定分支到当前分支</span><br><span class="line"><span class="meta">#</span>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</span><br><span class="line"><span class="meta">$</span> git merge [branch]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> git merge --no-ff -m "merge with no-ff" [branch]  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 选择一个commit，合并进当前分支</span><br><span class="line"><span class="meta">$</span> git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除分支</span><br><span class="line"><span class="meta">$</span> git branch -d [branch-name]</span><br><span class="line"><span class="meta">#</span>强制删除没有合并的分支</span><br><span class="line"><span class="meta">$</span> git branch -D [name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除远程分支</span><br><span class="line"><span class="meta">$</span> git push origin --delete &lt;branch-name&gt;</span><br><span class="line"><span class="meta">$</span> git branch -dr &lt;remote/branch&gt;</span><br></pre></td></tr></table></figure><h3 id="储存分支"><a href="#储存分支" class="headerlink" title="储存分支"></a>储存分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>存储当前分支工作现场</span><br><span class="line"><span class="meta">$</span> git stash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看存储的工作现场列表</span><br><span class="line"><span class="meta">$</span> git stash list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>恢复工作现场</span><br><span class="line"><span class="meta">$</span> git stash apply stash@&#123;Number&#125;</span><br><span class="line"><span class="meta">$</span> git stash pop</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [&lt;file&gt;]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复上一个commit的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line"># git archive</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Git的操作&quot;&gt;&lt;a href=&quot;#Git的操作&quot; class=&quot;headerlink&quot; title=&quot;Git的操作&quot;&gt;&lt;/a&gt;Git
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git搭建仓库</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-06-git%E6%90%AD%E5%BB%BA%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-06-git搭建仓库/</id>
    <published>2019-04-15T03:46:00.234Z</published>
    <updated>2019-04-15T03:49:23.166Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><p><strong>Git</strong> 是一个开源的分布式版本控制软件,用以有效、高速的处理从很小到非常大的项目版本管理。 Git 最初是由Linus Torvalds设计开发的，用于管理Linux内核开发。Git 是根据GNU通用公共许可证版本2的条款分发的自由/免费软件，安装参见：<a href="http://git-scm.com/" target="_blank" rel="noopener">http://git-scm.com/</a></p><p><strong>参考：</strong><br><a href="https://www.cnblogs.com/syp172654682/p/7689328.html" target="_blank" rel="noopener">深入浅出Git教程</a><br><br><a href="https://www.yiibai.com/git/git_reset.html" target="_blank" rel="noopener">Git命令教程</a><br><br><a href="https://github.com/geeeeeeeeek/git-recipes/wiki" target="_blank" rel="noopener">高质量的 Git 中文教程，来自国外社区的优秀文章和个人实践</a><br><br><a href="http://gitref.justjavac.com/" target="_blank" rel="noopener">Git参考手册</a></p><h2 id="windows系统配置git"><a href="#windows系统配置git" class="headerlink" title="windows系统配置git"></a>windows系统配置git</h2><p>前面安装过程不在阐述，直说下面如何配置git</p><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;xxx&quot;</span><br><span class="line">$ git config --global user.email &quot;xxx@xxx&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen  #按几次enter回车键，出现目录链接，然后找到xx.pub文件，打开文件，复制里面的内容到github中</span><br></pre></td></tr></table></figure><h2 id="操作git"><a href="#操作git" class="headerlink" title="操作git"></a>操作git</h2><blockquote><p><strong>获得git仓库</strong></p></blockquote><ol><li>通过命令 git init 把这个目录变成git可以管理的仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br></pre></td></tr></table></figure></li></ol><p>这时候你当前目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。</p><ol start="2"><li>克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地，而不是取某一个特定版本，所以用clone而不是checkout<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>把文件添加到版本库中</strong></p></blockquote><p>git版本控制系统可以告诉你每次的改动，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p>我在版本库目录中新建文本文件，如readme.txt<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一步:使用命令 git add添加到暂存区里面去</span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">第二步：用命令 git commit告诉Git，把文件提交到仓库。</span><br><span class="line">$ git commit -m &quot;readme.txt提交&quot;</span><br></pre></td></tr></table></figure><p></p><blockquote><p><strong>查看文件的状态</strong></p></blockquote><p>实际使用中你不止只有一个文件，或新增或修改多个文件，可能时间一久就忘了有多少文件需要提交，可以使用 git status 命令来查看当前状态,是否有未提交的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><blockquote><p><strong>比较当前文件跟版本文件内容</strong></p></blockquote><p>git diff用于显示WorkSpace中的文件和暂存区文件的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt</span><br><span class="line"></span><br><span class="line"># 查看已缓存的改动</span><br><span class="line">$ git diff --cached</span><br><span class="line"></span><br><span class="line"># 查看已缓存的与未缓存的所有改动</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line">#显示摘要而非整个 diff</span><br><span class="line">$ git diff --stat</span><br></pre></td></tr></table></figure><blockquote><p><strong>查看历史提交记录</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 历史纪录是根据时间倒叙排列的</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 一个压缩后的每一条提交记录只占一行的输出</span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line"></span><br><span class="line"># 只看某一个人的提交记录   </span><br><span class="line">$ git log --author=bob</span><br><span class="line"></span><br><span class="line"># ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签</span><br><span class="line">$ git log --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure><h2 id="文件4种状态"><a href="#文件4种状态" class="headerlink" title="文件4种状态"></a>文件4种状态</h2><ul><li><p>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p></li><li><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p></li><li><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</p></li><li><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified<br><img src="https://images2017.cnblogs.com/blog/63651/201709/63651-20170909091456335-1787774607.jpg" alt="文件4种状态"></p></li></ul><h2 id="理解工作区、暂存区和版本库的区别"><a href="#理解工作区、暂存区和版本库的区别" class="headerlink" title="理解工作区、暂存区和版本库的区别"></a><strong>理解工作区、暂存区和版本库的区别</strong></h2><p><strong>工作区域</strong>：<br>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/BEEA0855273E4CD6AEEBB58822EAF24A?method=download&amp;shareKey=453a30b0974277aea875341bc6cc1b35" alt="image"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li><li></li><li>工作区：就是你在电脑里能看到的目录。<br>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。<br>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br><img src="https://note.youdao.com/yws/api/personal/file/389823FEA5614CB8B6EE9CC40A01FEF9?method=download&amp;shareKey=b10514b7f23959b90d539b59435f06de" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/BBAAA9B4225E479BA04C89C1E6083C79?method=download&amp;shareKey=46ab5f4eb7cdb8f44199246b3180295b" alt="image"></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Git介绍&quot;&gt;&lt;a href=&quot;#Git介绍&quot; class=&quot;headerlink&quot; title=&quot;Git介绍&quot;&gt;&lt;/a&gt;Git介绍&lt;
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/04/02/hello-world/"/>
    <id>http://yoursite.com/2019/04/02/hello-world/</id>
    <published>2019-04-02T04:21:02.820Z</published>
    <updated>2019-04-02T04:21:02.820Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hex
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS 各种Hack手段</title>
    <link href="http://yoursite.com/2017/06/25/css-hack/"/>
    <id>http://yoursite.com/2017/06/25/css-hack/</id>
    <published>2017-06-24T19:25:24.000Z</published>
    <updated>2018-10-20T07:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><a id="more"></a><p>随着浏览器的发展，css hack 技术的使用应该越来越少了，但是在某些关键时刻以及综合的WEB应用或者老项目中，可能还需要使用 css hack 技术来解决一些问题。</p><h1 id="css-hack-分类"><a href="#css-hack-分类" class="headerlink" title="css hack 分类"></a>css hack 分类</h1><p>css hack 分类大致有 3 种表现形式：<strong>IE条件注释法</strong>、<strong>CSS属性前缀法</strong>以及<strong>选择器前缀法</strong>。</p><p>IE 条件注释法（即 HTML 条件注释 Hack）：<br>针对所有IE(注：IE10+ 已经不再支持条件注释)：<br><code>&lt;!--[if IE]&gt;IE浏览器显示的内容 &lt;![endif]--&gt;</code>；</p><p>针对 IE6 及以下版本：<br><code>&lt;!--[if lt IE 6]&gt;只在IE6-显示的内容 &lt;![endif]--&gt;</code>。<br>这类 Hack 不仅对 CSS 生效，对写在判断语句里面的所有代码都会生效。</p><p>属性前缀法（即类内部 Hack）：例如 IE6 能识别下划线 <code>_</code> 和星号 <code>*</code>，IE7 能识别星号 <code>*</code>，但不能识别下划线 <code>_</code>，IE6~IE10 都认识 <code>\9</code>，但 firefox 前述三个都不能认识。</p><p>选择器前缀法（即选择器 Hack）：例如 IE6 能识别 <code>*html .class{}</code>，IE7 能识别 <code>*+html .class{}</code> 或者 <code>*:first-child+html .class{}</code>。</p><p>css hack 书写顺序，一般是将适用范围广、被识别能力强的 CSS 定义在前面。</p><h1 id="条件注释法"><a href="#条件注释法" class="headerlink" title="条件注释法"></a>条件注释法</h1><p><strong>语法：</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if &lt;keywords&gt;? IE &lt;version&gt; ?]&gt;</span></span><br><span class="line"><span class="comment">HTML 代码块</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>取值：</strong><br><code>&lt;keywords&gt;</code><br>if 条件共包含 6 种选择方式：是否、大于、大于或等于、小于、小于或等于、非指定版本<br><strong>是否</strong>：指定是否 IE 或 IE 某个版本。关键字：空<br><strong>大于</strong>：选择大鱼指定版本的 IE 版本。关键字：gt<br><strong>大于或等于</strong>：选择大于或等于指定版本的 IE 版本。关键字：gte<br><strong>小于</strong>：选择小于指定版本的IE版本。关键字：lt<br><strong>小于或等于</strong>：选择小于或等于指定版本的IE版本。关键字：lte<br><strong>非指定版本</strong>：选择除指定版本外的所有IE版本。关键字：!</p><p><strong>说明：</strong><br>用于选择 IE 浏览器及IE的不同版本</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">只在IE下生效</span><br><span class="line">&lt;!--[if IE]&gt;</span><br><span class="line">这段文字只在IE浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">只在IE6下生效</span><br><span class="line">&lt;!--[if IE 6]&gt;</span><br><span class="line">这段文字只在IE6浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">只在IE6以上版本生效</span><br><span class="line">&lt;!--[if gte IE 6]&gt;</span><br><span class="line">这段文字只在IE6以上(包括)版本IE浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">只在IE8上不生效</span><br><span class="line">&lt;!--[if ! IE 8]&gt;</span><br><span class="line">这段文字在非IE8浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">非IE浏览器生效</span><br><span class="line">&lt;!--[if !IE]&gt;</span><br><span class="line">这段文字只在非IE浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><p>需要说明的是，IE10和11已经不支持这种条件注释法了。<a href="/yu/css-hack.html" target="_blank">运行上面示例</a></p><h1 id="CSS-属性前缀法"><a href="#CSS-属性前缀法" class="headerlink" title="CSS 属性前缀法"></a>CSS 属性前缀法</h1><p><strong>语法：</strong><br>selector {<hack>?property:value<hack>?;}</hack></hack></p><p><strong>取值：</strong><br><code>_</code>：选择 IE6 及以下。连接线（中划线）（-）亦可使用，为了避免与某些带中划线的属性混淆，所以使用下划线（_）更为合适。<br><code>*</code>：选择 IE7 及以下。诸如：（+）与（#）之类的均可使用，不过业界对（*）的认知度更高。<br><code>\9</code>：选择 IE6+。<br><code>\0</code>：选择 IE8+ 和 Opera。<br><code>[;property:value;];</code>：选择 webkit 核心浏览器（Chrome,Safari）。IE7 及以下也能识别。中括号内外的 3 个分号必须保留，第一个分号前可以是任意规则或任意多个规则。<br><code>[;color:#f00;];</code> 与 <code>[color:#f00;color:#f00;];</code> 与 <code>[margin:0;padding:0;color:#f00;];</code> 是等价的。生效的始终是中括号内的最后一条规则，所以通常选用第一种写法最为简洁。</p><p><strong>说明：</strong><br><strong>选择不同的浏览器及版本</strong>尽可能减少对 CSS Hack 的使用。Hack 有风险，谨慎使用。<br>一些 CSS Hack 由于浏览器存在交叉认识，所以需要通过层层覆盖的方式来实现对不同浏览器进行 Hack 的。如下面这个例子：<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#090</span>\<span class="number">9</span>; <span class="comment">/* For IE8+ */</span></span><br><span class="line">  *color:#f00;  /* For IE7 and earlier */</span><br><span class="line">  _<span class="selector-tag">color</span>:<span class="selector-id">#ff0</span>;  <span class="comment">/* For IE6 and earlier */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p id="div-border-left-yellow">上述 Hack 均需运行在标准模式下，若在怪异模式下运行，这些 Hack 将会被不同版本的 IE 相互识别，导致失效。</p><h1 id="选择器前缀法"><a href="#选择器前缀法" class="headerlink" title="选择器前缀法"></a>选择器前缀法</h1><p><strong>语法：</strong><br><code>&lt;hack&gt;selector{sRules}</code></p><p><strong>说明：</strong><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="selector-tag">html</span> <span class="selector-class">.test</span>&#123;<span class="attribute">color</span>:<span class="number">#090</span>;&#125;       <span class="comment">/* For IE6 and earlier */</span></span><br><span class="line">* + <span class="selector-tag">html</span> <span class="selector-class">.test</span>&#123;<span class="attribute">color</span>:<span class="number">#ff0</span>;&#125;     <span class="comment">/* For IE7 */</span></span><br><span class="line"><span class="selector-class">.test</span><span class="selector-pseudo">:lang(zh-cn)</span>&#123;<span class="attribute">color</span>:<span class="number">#f00</span>;&#125;  <span class="comment">/* For IE8+ and not IE */</span></span><br><span class="line"><span class="selector-class">.test</span><span class="selector-pseudo">:nth-child(1)</span>&#123;<span class="attribute">color</span>:<span class="number">#0ff</span>;&#125; <span class="comment">/* For IE9+ and not IE */</span></span><br></pre></td></tr></table></figure><p></p><p id="div-border-left-yellow">上述代码中的3,4两行就是典型的利用能力来进行选择的 CSS Hack。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（六）：Spring Cloud Config</title>
    <link href="http://yoursite.com/2017/06/18/Spring%20Cloud%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86Spring%20Cloud%20Config/"/>
    <id>http://yoursite.com/2017/06/18/Spring Cloud（六）：分布式配置管理Spring Cloud Config/</id>
    <published>2017-06-18T05:25:24.000Z</published>
    <updated>2019-06-18T03:42:49.153Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ul><li>提供服务端和客户端支持</li><li>集中管理个环境的配置文件</li><li>配置文件修改之后，可以快速生效</li><li>可以进行版本控制（使用git）</li><li>支持大的并发查询</li><li>支持各种语言</li></ul><p>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。</p><h1 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h1><p>在github上面创建文件夹config-repo，然后往里面添加dev/sit/prod三个配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config-dev.properties</span><br><span class="line">config-sit.properties</span><br><span class="line">config-prod.properties</span><br></pre></td></tr></table></figure><h2 id="server端"><a href="#server端" class="headerlink" title="server端"></a><strong>server端</strong></h2><h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><p>为了支持版本控制功能，推荐使用git</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">spring-cloud-config-server</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line">          <span class="comment"># 配置git仓库的地址</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://github.com/ityouknow/spring-cloud-starter/</span>     </span><br><span class="line">          <span class="comment"># git仓库地址下的相对地址，可以配置多个，用,分割。</span></span><br><span class="line"><span class="attr">          search-paths:</span> <span class="string">config-repo</span>      </span><br><span class="line">          <span class="comment"># git仓库的账号</span></span><br><span class="line"><span class="attr">          username:</span> </span><br><span class="line">          <span class="comment"># git仓库的密码</span></span><br><span class="line"><span class="attr">          password:</span></span><br></pre></td></tr></table></figure><ul><li>本地存储配置的方式：只需要设置为<code>spring.profiles.active=native</code>，Config Server 默认从应用的src/main/resource目录中去检索配置文件</li><li>外部目录存储：<code>spring.cloud.config.server.native.searchLocations=file:E:/properties/</code>属性来指定配置文件的位置</li></ul><h3 id="3、启动类"><a href="#3、启动类" class="headerlink" title="3、启动类"></a>3、启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入注解@EnableConfigServer</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、测试server端是否可以访问配置信息"><a href="#4、测试server端是否可以访问配置信息" class="headerlink" title="4、测试server端是否可以访问配置信息"></a>4、测试server端是否可以访问配置信息</h3><p>直接访问<code>http://localhost:8001/config/dev</code>，访问config-dev.properties配置文件</p><p>返回的信息包含了配置文件的位置、版本、配置文件的名称以及配置文件中的具体内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;config&quot;, </span><br><span class="line">    &quot;profiles&quot;: [</span><br><span class="line">        &quot;dev&quot;</span><br><span class="line">    ], </span><br><span class="line">    &quot;label&quot;: null, </span><br><span class="line">    &quot;version&quot;: null, </span><br><span class="line">    &quot;state&quot;: null, </span><br><span class="line">    &quot;propertySources&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;git地址/config-repo/config-dev.properties&quot;, </span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;hello&quot;: &quot;hello im dev&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果访问的URL为<code>http://localhost:8001/config-dev.properties</code>，则直接放回配置文件的内容</p><blockquote><p>仓库中的配置文件会被转换成web接口，访问可以参照以下的规则：</p><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><p>以config-dev.properties为例子，它的application是config，profile是dev。client会根据填写的参数来选择读取对应的配置。</p></blockquote><h2 id="client端"><a href="#client端" class="headerlink" title="client端"></a><strong>client端</strong></h2><h3 id="1、添加依赖-1"><a href="#1、添加依赖-1" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><p>同样需要添加同服务端的依赖</p><h3 id="2、配置文件-1"><a href="#2、配置文件-1" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><p>配置两个配置文件，application.properties和bootstrap.properties</p><p>application.properties如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=spring-cloud-config-client</span><br><span class="line">server.port=8002</span><br></pre></td></tr></table></figure><p>bootstrap.properties如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#对应&#123;application&#125;部分</span><br><span class="line">spring.cloud.config.name=config</span><br><span class="line">#对应&#123;profile&#125;部分</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">#配置中心的具体地址</span><br><span class="line">spring.cloud.config.uri=http://localhost:8001/</span><br><span class="line">#对应git的分支。如果配置中心使用的是本地存储，则该参数无用</span><br><span class="line">spring.cloud.config.label=master</span><br></pre></td></tr></table></figure><blockquote><p>特别注意：上面这些与spring-cloud相关的属性必须配置在bootstrap.properties中，config部分内容才能被正确加载。因为config的相关配置会先于application.properties，而bootstrap.properties的加载也是先于application.properties。</p></blockquote><h3 id="3、启动类-1"><a href="#3、启动类-1" class="headerlink" title="3、启动类"></a>3、启动类</h3><p>只需要用<code>@SpringBootApplication</code>就可以了</p><h3 id="4、client端测试"><a href="#4、client端测试" class="headerlink" title="4、client端测试"></a>4、client端测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用@Value注解来获取server端参数的值</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、更新配置文件——自动-手动通知"><a href="#5、更新配置文件——自动-手动通知" class="headerlink" title="5、更新配置文件——自动/手动通知"></a>5、更新配置文件——自动/手动通知</h3><p><strong>如果修改git上面的配置文件后，再次访问浏览器URL后，获取的信息还是旧的参数？</strong></p><p><strong>答</strong>：因为spring boot 项目只有启动的时候才会获取配置文件的值，修改github信息后，client端并没有再次获取</p><p><strong>解决办法</strong>：每个客户端通过POST方法触发各自的<code>/refresh</code>。</p><ul><li>添加依赖</li></ul><p>增加了<code>spring-boot-starter-actuator</code>包，<code>spring-boot-starter-actuator</code>是一套监控的功能，可以监控程序在运行时状态，其中就包括<code>/refresh</code>的功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>开启更新机制</p><p>需要给加载变量的类上面加载<code>@RefreshScope</code>，在客户端执行<code>/refresh</code>的时候就会更新此类下面的变量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">// 使用该注解的类，会在接到SpringCloud配置中心配置刷新的时候，自动将新的配置更新到该类对应的字段中。</span></span><br><span class="line"><span class="meta">@RefreshScope</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hello;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试（手动更新）</p><p>springboot 1.5.X 以上默认开通了安全认证，所以需要在配置文件application.properties添加以下配置*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.security.enabled=false</span><br></pre></td></tr></table></figure><p>再以post请求的方式来访问<code>http://localhost:8002/refresh</code> 就会更新修改后的配置文件。</p><p>在win上面打开cmd执行<code>curl -X POST http://localhost:8002/refresh</code>，返回<code>[&quot;hello&quot;]</code>表示已经更新</p></li><li><p>webhook（自动更新）在github上操作</p><p>WebHook是当某个事件发生时，通过发送http post请求的方式来通知信息接收方。Webhook来监测你在Github.com上的各种事件，最常见的莫过于push事件。如果你设置了一个监测push事件的Webhook，那么每当你的这个项目有了任何提交，这个Webhook都会被触发，这时Github就会发送一个HTTP<br>POST请求到你配置好的地址。</p></li><li><p>Spring Cloud Bus 消息总线</p></li></ul><h1 id="三、配置中心服务化和高可用"><a href="#三、配置中心服务化和高可用" class="headerlink" title="三、配置中心服务化和高可用"></a>三、配置中心服务化和高可用</h1><h2 id="server端改造"><a href="#server端改造" class="headerlink" title="server端改造"></a>server端改造</h2><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、配置文件</p><p>将server端加到注册中心里</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8000/eureka/</span>   <span class="comment">## 注册中心eurka地址</span></span><br></pre></td></tr></table></figure><h2 id="client端改造"><a href="#client端改造" class="headerlink" title="client端改造"></a>client端改造</h2><p>1、添加依赖：加入eureka的依赖</p><p>2、配置文件</p><p>bootstrap.properties文件</p><p>去掉<code>spring.cloud.config.uri</code>直接指向server端地址的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#开启Config服务发现支持</span><br><span class="line">spring.cloud.config.discovery.enabled=true</span><br><span class="line">#指定server端的name,也就是server端spring.application.name的值</span><br><span class="line">spring.cloud.config.discovery.serviceId=spring-cloud-config-server</span><br><span class="line">#指向注册中心的地址</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/</span><br></pre></td></tr></table></figure><h1 id="四、消息总线Spring-Cloud-Bus"><a href="#四、消息总线Spring-Cloud-Bus" class="headerlink" title="四、消息总线Spring Cloud Bus"></a>四、消息总线Spring Cloud Bus</h1><p><strong>方式一</strong>：某个微服务承担配置刷新的职责</p><p><img src="https://note.youdao.com/yws/api/personal/file/4B0BADFF99E648469498FAF62BEAB72E?method=download&amp;shareKey=df3a7ed59b3088ba7bc8b856d8840f64" alt></p><ul><li>1、提交代码触发post给客户端A发送bus/refresh</li><li>2、客户端A接收到请求从Server端更新配置并且发送给Spring Cloud Bus</li><li>3、Spring Cloud bus接到消息并通知给其它客户端</li><li>4、其它客户端接收到通知，请求Server端获取最新配置</li><li>5、全部客户端均获取到最新的配置</li></ul><p>存在问题：</p><p>1、打破了微服务的职责单一性。微服务本身是业务模块，它本不应该承担配置刷新的职责。</p><p>2、破坏了微服务各节点的对等性。</p><p>3、有一定的局限性。WebHook的配置随着承担刷新配置的微服务节点发生改变。</p><p><strong>方式二</strong>：配置中心Server端承担起配置刷新的职责</p><p><img src="https://note.youdao.com/yws/api/personal/file/62E22B57EC1B4B84AE79D7D2B359F8FA?method=download&amp;shareKey=dad74118dd83ef1095bd4d7ea0ea09d7" alt></p><ul><li>1、提交代码触发post请求给bus/refresh</li><li>2、server端接收到请求并发送给Spring Cloud Bus</li><li>3、Spring Cloud bus接到消息并通知给其它客户端</li><li>4、其它客户端接收到通知，请求Server端获取最新配置</li><li>5、全部客户端均获取到最新的配置</li></ul><h2 id="client端改造（方式一）"><a href="#client端改造（方式一）" class="headerlink" title="client端改造（方式一）"></a>client端改造（方式一）</h2><h3 id="1、添加依赖-2"><a href="#1、添加依赖-2" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、配置文件-2"><a href="#2、配置文件-2" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## 刷新时，关闭安全验证</span><br><span class="line">management.security.enabled=false</span><br><span class="line">## 开启消息跟踪</span><br><span class="line">spring.cloud.bus.trace.enabled=true</span><br><span class="line"></span><br><span class="line">spring.rabbitmq.host=192.168.9.89</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=123456</span><br></pre></td></tr></table></figure><h3 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h3><p>webhook向客户端发送一个/bus/refresh的POST请求，然后再依次访问其他的客户端，均能拿到最新的配置文件的信息</p><h2 id="server端改进版本（方式二）"><a href="#server端改进版本（方式二）" class="headerlink" title="server端改进版本（方式二）"></a>server端改进版本（方式二）</h2><h3 id="1、添加依赖-3"><a href="#1、添加依赖-3" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--增加对消息总线的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、配置文件-3"><a href="#2、配置文件-3" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          # 配置git仓库的地址</span><br><span class="line">          uri: https://github.com/ityouknow/spring-cloud-starter/     </span><br><span class="line">          # git仓库地址下的相对地址，可以配置多个，用,分割。</span><br><span class="line">          search-paths: config-repo     </span><br><span class="line">          # git仓库的账号</span><br><span class="line">          username: username</span><br><span class="line">          # git仓库的密码</span><br><span class="line">          password: password                                    </span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.0.6</span><br><span class="line">    port: 5672</span><br><span class="line">    username: admin</span><br><span class="line">    password: 123456</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8000/eureka/   ## 注册中心eurka地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  security:</span><br><span class="line">     enabled: false</span><br></pre></td></tr></table></figure><h3 id="3、测试-1"><a href="#3、测试-1" class="headerlink" title="3、测试"></a>3、测试</h3><p>webhook向服务端发送一个/bus/refresh的POST请求，然后再依次访问其他的客户端，均能拿到最新的配置文件的信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模拟webhook触发server端的bus/refresh --&gt;</span></span><br><span class="line">curl -X POST http://localhost:8001/bus/refresh</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;
      
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://yoursite.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>gulp 详解与使用</title>
    <link href="http://yoursite.com/2017/05/01/gulp/"/>
    <id>http://yoursite.com/2017/05/01/gulp/</id>
    <published>2017-04-30T17:25:24.000Z</published>
    <updated>2018-10-20T07:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:34 GMT+0800 (GMT+08:00) --><h1 id="什么是-gulp"><a href="#什么是-gulp" class="headerlink" title="什么是 gulp"></a>什么是 gulp</h1><p><a href="http://gulpjs.com/" target="_blank" rel="noopener">gulp</a> 是一个前端构建工具，它能通过自动执行常见任务，比如编译预处理 CSS ，压缩 JavaScript 和刷新浏览器，来改进网站开发的过程，从而使开发更加快速高效。</p><h1 id="为什么要用-gulp"><a href="#为什么要用-gulp" class="headerlink" title="为什么要用 gulp"></a>为什么要用 gulp</h1><p>与 grunt 相比，gulp 无需写一大堆繁杂的配置参数，<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">API</a>（<a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">中文 API</a>） 也非常简单，学习起来很容易，而且 gulp 使用的是 nodejs 中 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">stream</a> 来读取和操作数据，其速度更快。<br>gulp 有庞大的生态圈，且每天都在发展。依靠成千上万可供选择的插件，你可以利用 gulp 自动完成几乎任何事。</p><h1 id="如何使用-gulp"><a href="#如何使用-gulp" class="headerlink" title="如何使用 gulp"></a>如何使用 gulp</h1><h2 id="Installing-Gulp"><a href="#Installing-Gulp" class="headerlink" title="Installing Gulp"></a>Installing Gulp</h2><p>新版的 gulp 命令行工具已经改名为 gulp-cli 。<br>如果你之前安装了全局的 gulp 。在使用新的 gulp-cli 之前，执行命令<br><code>npm rm --global gulp</code> ，将之前的全局 gulp 卸掉。</p><a id="more"></a><h3 id="Install-the-gulp-command"><a href="#Install-the-gulp-command" class="headerlink" title="Install the gulp command"></a>Install the gulp command</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli</span><br></pre></td></tr></table></figure><h3 id="Install-gulp-in-your-devDependencies"><a href="#Install-gulp-in-your-devDependencies" class="headerlink" title="Install gulp in your devDependencies"></a>Install gulp in your devDependencies</h3><p>Run this command in your project directory<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br></pre></td></tr></table></figure><p></p><h2 id="Create-a-gulpfile"><a href="#Create-a-gulpfile" class="headerlink" title="Create a gulpfile"></a>Create a gulpfile</h2><p>Create a file called gulpfile.js in your project root with these contents:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// place code for your default tash here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h2 id="Test-it-out"><a href="#Test-it-out" class="headerlink" title="Test it out"></a>Test it out</h2><p>Run the gulp command in your projct directory:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure><p></p><h1 id="gulp-API"><a href="#gulp-API" class="headerlink" title="gulp API"></a>gulp API</h1><p>gulp 的核心 API 有四个：gulp.task() 、 gulp.src() 、 gulp.dest() 、 gulp.watch() 。<br><a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">gulp API</a><br><a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">gulp API 中文</a></p><p>下面详细介绍一下：</p><h2 id="gulp-src"><a href="#gulp-src" class="headerlink" title="gulp.src()"></a>gulp.src()</h2><p>gulp.src() 可以读取你需要操作的文件，相比于 Grunt 主要以文件为媒介来运行它的工作流，gulp 使用的是 Nodejs 中的 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">stream</a> 流，首先获取到需要的 stream ，然后可以通过 stream 的 pipe() 方法把流导入到你想要的地方，比如 gulp 的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以 gulp 是以 stream 为媒介的，它不需要频繁的生成临时文件，这也是 gulp 的速度比 Grunt 快的一个原因。再回到正题上来，gulp.src() 方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流（Vinyl files），这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，这个我们暂时不用去深入理解，你只需简单的理解可以用这个方法来读取你需要操作的文件就行了。其语法为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(globs [, options])</span><br></pre></td></tr></table></figure><p></p><p>gulp 用到的 glob 的匹配规则以及一些文件匹配技巧。<br>gulp 内部使用了 node-glob 模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：</p><ul><li><code>*</code> 匹配文件路径中的 0 个或多个字符，但不会匹配路径分配符，除非路径分隔符出现在末尾</li><li>** 匹配路径中的 0 个或多个目录及其子目录，需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。</li><li>? 匹配文件路径中的一个字符（不会匹配路径分隔符）</li><li>[…] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为 ^ 或 ! 时，则表示不匹配方括号中出现的其他字符中的任意一个，类似 js 正则表达式中的用法。</li><li>!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的</li><li>?(pattern|pattern|pattern) 匹配括号中给定的任一模式 0 次或 1 次，类似于 js 正则中的(pattern|pattern|pattern)?</li><li>+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少 1 次，类似于正则中的(pattern|pattern|pattern)+</li><li><code>*(pattern|pattern|pattern)</code> 匹配括号中的给定的任一模式 0 次或多次，类似于 js 正则中的 <code>(pattern|pattern|pattern)*</code></li><li>@(pattern|pattern|pattern) 匹配括号中给定的任一模式 1 次，类似于 js 正则中的(pattern|pattern|pattern)</li></ul><p>下面以一系列例子来加深理解</p><ul><li><code>*</code> 能匹配 a.js 、 x.y 、 abc 、 abc/ ，但不能匹配 a/b.js</li><li><code>*.*</code> 能匹配 a.js 、 style.css 、 a.b 、 x.y</li><li><code>*/*/*.js</code> 能匹配 a/b/c.js 、 x/y/z.js ，不能匹配 a/b.js 、a/b/c/d.js</li><li>** 能匹配 abc 、 a/b.js 、 a/b/c.js 、 x/y/z 、x/y/z/a.b ，能用来匹配所有的目录和文件</li><li>*<em>/</em>.js 能匹配 foo.js 、 a/foo.js 、 a/b/foo.js 、 a/b/c/foo.js</li><li>a/**/z 能匹配 a/z 、 a/b/z 、 a/b/c/z 、 a/d/g/h/r/z</li><li><code>a/**b/z</code> 能匹配 a/b/z 、 a/fb/z ，但不能匹配 a/x/gb/z ，因为只有单 ** 单独出现才能匹配多级目录</li><li>?.js 能匹配 a.js 、 b.js 、 c.js</li><li>a?? 能匹配 a.b 、 abc ，但不能匹配 ab/ ，因为它不会匹配路径分隔符</li><li>[xyz].js 只能匹配 x.js 、 y.js 、 z.js ，不会匹配 xy.js 、 xyz.js 等，整个中括号只代表一个字符</li><li>[^xyz].js 能匹配 a.js 、 b.js 、 c.js 等，不能匹配 x.js 、 y.js 、 z.js</li></ul><p>当有多种匹配模式时可以使用数组<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组的方式来匹配多种文件</span></span><br><span class="line">gulp.src([<span class="string">'js/*.js'</span>,<span class="string">'css/*.css'</span>,<span class="string">'*.html'</span>])</span><br></pre></td></tr></table></figure><p></p><p>使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上 ! 即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gulp.src([*.js,<span class="string">'!b*.js'</span>])  <span class="comment">//匹配所有 js 文件，但排除掉以 b 开头的 js 文件</span></span><br><span class="line">gulp.src([<span class="string">'!b*.js'</span>,*.js])  <span class="comment">//不会排除任何文件，因为排除模式不能出现在数组的第一个元素中</span></span><br></pre></td></tr></table></figure><p></p><p>此外，还可以使用展开模式。展开模式以花括号作为定界符，根据它里面的内容，会展开为多个模式，最后匹配的结果为所有展开的模式想加起来得到的结果。展开的例子如下：</p><ul><li>a{b,c}d 会展开为 abd 、 acd</li><li>a{b,}c 会展开为 abc 、 ac</li><li>a{0..3}d 会展开为 a0d 、 a1d 、 a2d 、 a3d</li><li>a{b,c{d,e}f}g 会展开为 abg 、 acdfg 、 acefg</li><li>a{b,c}d{e,f}g 会展开为 abdeg 、 acdeg 、 abdfg 、 abdeg</li></ul><h2 id="gulp-dest"><a href="#gulp-dest" class="headerlink" title="gulp.dest()"></a>gulp.dest()</h2><p>gulp.dest() 方法是用来写文件的，其语法为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.dest(path[, options])</span><br></pre></td></tr></table></figure><p></p><p><strong>path</strong> 为写入文件的路径<br>我们给 gulp.dest() 传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当作是目录名，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</span><br><span class="line">gulp.src(<span class="string">"script/jquery.js"</span>).pipe(gulp.dest(<span class="string">"dist/foo.js"</span>));</span><br><span class="line"><span class="comment">// 最终生成的文件路径为 dist/foo.js/jquery.js ，而不是 dist/foo.js</span></span><br></pre></td></tr></table></figure><p></p><p>要想改变文件名，可以使用插件 gulp-rename<br>下面说说生成的文件路径与我们给 gulp.dest() 方法传入的路径参数之间的关系。<br>gulp.dest(path) 生成的文件路径是我们传入的 path 参数后面再加上 gulp.src() 中有通配符开始出现的那部分路径。例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</span><br><span class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/*.js</span></span><br><span class="line">gulp.src(<span class="string">"script/**/*.js"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//最后生成的文件路径为 dist/**/*.js</span></span><br><span class="line"><span class="comment">//如果 **/*.js 匹配到的文件为 jquery/jquery.js ，则生成的文件路径为 dist/jquery/jquery.js</span></span><br></pre></td></tr></table></figure><p></p><p>再举更多一点的例子<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"script/avalon/avalon.js"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//没有通配符出现的情况，最后生成的文件路径为 dist/avalon.js</span></span><br><span class="line"></span><br><span class="line">gulp.src(<span class="string">"script/**/underscore.js"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/underscore.js</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/util/underscore.js</span></span><br><span class="line"><span class="comment">//则最后生成的文件路径为dist/util/underscore.js</span></span><br><span class="line"></span><br><span class="line">gulp.src(<span class="string">"script/*"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//有通配符出现的那部分路径为*</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/zepto.js</span></span><br><span class="line"><span class="comment">//则最后生成的文件路径为dist/zepto.js</span></span><br></pre></td></tr></table></figure><p></p><p>通过指定 gulp.src() 方法配置参数中的 base 属性，我们可以灵活的来改变 gulp.dest() 生成的文件路径。<br>当我们没有在 gulp.src() 方法配置参数中的 base 属性，base 的默认值为通配符开始出现之前那部分路径，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"app/src/**/*.css"</span>) <span class="comment">//此时base的值为 app/src</span></span><br></pre></td></tr></table></figure><p></p><p>上面我们说的 gulp.dest() 所生成的文件路径的规则，其实也可以理解成，用我们给 gulp.dest() 传入的路径替换掉 gulp.src() 中的 base 路径，最终得到生成文件的路径。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"app/src/**/*.css"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//此时base的值为app/src，也就是说它的base路径为app/src</span></span><br><span class="line"><span class="comment">//设该模式匹配到了文件app/src/css/normal.css</span></span><br><span class="line"><span class="comment">//用dist替换掉base路径，最终得到dist/css/normal.css</span></span><br></pre></td></tr></table></figure><p></p><p>所以改变 base 路径后，gulp.dest() 生成的文件路径也会改变<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"script/lib/*.js"</span>).pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line"><span class="comment">//没有配置base参数，此时默认的base路径为script/lib</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/lib/jquery.js</span></span><br><span class="line"><span class="comment">//生成的文件路径为build/jquery.js</span></span><br><span class="line"></span><br><span class="line">gulp.src(<span class="string">"script/lib/*.js"</span>, &#123;<span class="attr">base</span>: <span class="string">"script"</span>&#125;).pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line"><span class="comment">//配置了base参数，此时base路径为script</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/lib/jquery.js</span></span><br><span class="line"><span class="comment">//此时生成的文件路径为build/lib/jquery.js</span></span><br></pre></td></tr></table></figure><p></p><p>用 gulp.dest() 把文件流写入文件后，文件流仍然可以继续使用。</p><h2 id="gulp-task"><a href="#gulp-task" class="headerlink" title="gulp.task()"></a>gulp.task()</h2><p>gulp.task 方法用来定义任务，内部使用的是 Orchestrator ，其语法为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(name[, deps], fn)</span><br></pre></td></tr></table></figure><p></p><p><strong>name</strong> 为任务名，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。<br><strong>deps</strong> 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数。<br><strong>fn</strong> 为任务函数，我们把任务要执行的代码都要写在里面。该参数也是可选的。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"mytask"</span>, [<span class="string">"array"</span>, <span class="string">"of"</span>, <span class="string">"task"</span>, <span class="string">"names"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个有依赖的任务</span></span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>关于 gulp.task() ，我们需要知道执行多个任务时怎么来控制任务执行的顺序。<br>gulp 中执行多个任务，可以通过任务依赖来实现。例如我想要执行 one ，two ，three 这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要执行default任务，就相当于把one,two,three这三个任务执行了</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>,[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>]);</span><br></pre></td></tr></table></figure><p></p><p>如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。<br>但是如果某个任务所依赖的任务是异步的，就要注意了，gulp 并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// one是一个异步执行的任务</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"one is done"</span>);</span><br><span class="line">  &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//two任务虽然依赖于one任务，但并不会等到one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/gulp-1.png" alt><br>上面的例子中我们执行 two 任务时，会先执行 one 任务，但不会去等待 one 任务中的异步操作完成后再执行 two 任务，而是紧接着执行 two 任务。因为 one 任务耗时 3 秒，所以 two 任务会在 one 任务中的异步操作完成之前就执行了。</p><p>那如果我们想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？<br>有三种方法可以实现：</p><p>第一：在异步操作完成后执行一个回调函数来通知 gulp 这个异步任务已经完成，这个回调函数就是任务函数的第一个参数。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"one"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//cb为任务函数提供的回调，用来通知任务已经完成</span></span><br><span class="line">  <span class="comment">//one是一个异步执行的任务</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"one is done"</span>);</span><br><span class="line">    cb(); <span class="comment">//执行回调，表示这个异步任务已经完成</span></span><br><span class="line">  &#125;,<span class="number">5000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时two任务会在one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>第二：定义任务时返回一个流对象。适用于任务就是操作 gulp.src 获取到的流的情况。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"one"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stream = gulp.src(<span class="string">"client/**/*.js"</span>)</span><br><span class="line">      .pipe(dosomething()) <span class="comment">//dosomething()中有某些异步操作</span></span><br><span class="line">      .pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是two任务会在one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>第三：返回一个 promise 对象，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>); <span class="comment">//一个著名的异步处理的库 https://github.com/kriskowal/q</span></span><br><span class="line">gulp.task(<span class="string">"one"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line">  <span class="comment">//做一些异步操作</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    deferred.resolve();</span><br><span class="line">  &#125;,<span class="number">5000</span>);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>关于 gulp.task() ，主要的就是要清除当依赖异步任务时要如何处理。</p><h2 id="gulp-watch"><a href="#gulp-watch" class="headerlink" title="gulp.watch()"></a>gulp.watch()</h2><p>gulp.watch() 用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(glob[, opts], tasks);</span><br></pre></td></tr></table></figure><p></p><p><strong>glob</strong> 为要监视的文件匹配模式，规则和用法与 gulp.src() 方法中的 glob 相同。<br><strong>opts</strong> 为一个可选的配置对象，通常不需要用到。<br><strong>tasks</strong> 为文件变化后要执行的任务，为一个数组<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"uglify"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">"reload"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br><span class="line">gulp.watch(<span class="string">"js/**/*.js"</span>, [<span class="string">"uglify"</span>,<span class="string">"reload"</span>]);</span><br></pre></td></tr></table></figure><p></p><p>gulp.watch(glob [,opts, cb])<br><strong>glob</strong> 和 <strong>opts</strong> 参数与第一种用法相同<br><strong>cb</strong> 参数为一个函数。每当监视的文件发生变化时，就会调用这个函数，并且会给它传入一个对象，该对象包含了文件变化的一些信息，type 属性为变化的类型，可以是 added 、changed 、deleted ，path 属性为发生变化的文件的路径<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(<span class="string">"js/**/*.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type); <span class="comment">//变化类型added为新增，deleted为删除，changed为改变</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.path); <span class="comment">//变化的文件的路径</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h1 id="gulp-的插件"><a href="#gulp-的插件" class="headerlink" title="gulp 的插件"></a>gulp 的插件</h1><p>gulp 本身虽然不能完成很多任务，但它有大量插件可用，我们可以在 <a href="http://gulpjs.com/plugins/" target="_blank" rel="noopener">插件页面</a> 或者在 npm 搜索 gulpplugin 。<br>列一些很棒的 plugin ：</p><ul><li><a href="https://www.npmjs.com/package/gulp-jshint/" target="_blank" rel="noopener">JSHint</a> ： js代码检查分析工具</li><li><a href="https://www.npmjs.com/package/gulp-coffee/" target="_blank" rel="noopener">gulp-coffee</a> ： 编译CoffeeScript</li><li><a href="https://www.npmjs.com/package/gulp-mocha" target="_blank" rel="noopener">gulp-mocha</a> ： 执行Mocha测试</li><li><a href="https://www.npmjs.com/package/gulp-bump" target="_blank" rel="noopener">gulp-bump</a> ： 更新版本号</li><li><a href="https://www.npmjs.com/package/gulp-sass" target="_blank" rel="noopener">gulp-sass</a> ： sass 编译</li><li><a href="http://www.browsersync.cn/docs/gulp/" target="_blank" rel="noopener">browser-sync</a> ： 浏览器自动刷新</li><li><a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a> ： 代码压缩</li><li><a href="https://www.npmjs.com/package/gulp-concat" target="_blank" rel="noopener">gulp-concat</a> ： 合并</li><li><a href="https://www.npmjs.com/package/gulp-eslint" target="_blank" rel="noopener">gulp-eslint</a> ： 支持 ES6 JSX</li></ul><h1 id="gulp-命令行参数"><a href="#gulp-命令行参数" class="headerlink" title="gulp 命令行参数"></a>gulp 命令行参数</h1><ul><li><code>-v</code> 或 <code>--version</code> 会显示全局和项目本地所安装的 gulp 版本号</li><li><code>--require &lt;module path&gt;</code> 将会在执行之前 require 一个模块。这对于一些语言编译器或者需要其他应用的情况来说很有用。你可以使用多个 <code>--require</code></li><li><code>--gulpfile &lt;gulpfile path&gt;</code> 手动指定一个 gulpfile 的路径，这在你有很多个 gulpfile 的时候很有用。这也会将 CWD 设置到该 gulpfile 所在目录</li><li><code>--cwd &lt;dir path&gt;</code> 手动指定 CWD 。定义 gulpfile 查找的位置，此外，所有的相应的依赖（require）会从这里开始计算相对路径</li><li><code>-T</code> 或 <code>--tasks</code> 会显示所指定 gulpfile 的 task 依赖树</li><li><code>--tasks-simple</code> 会以纯文本的方式显示所载入的 gulpfile 中的 task 列表</li><li><code>--color</code> 强制 gulp 和 gulp 插件显示颜色，即便没有颜色支持</li><li><code>--no-color</code> 强制不显示颜色，即便检测到有颜色支持</li><li><code>--silent</code> 禁止所有的 gulp 日志</li></ul><p>命令行会在 process.env.INIT_CW 中记录它是从哪里被运行的。</p><h1 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h1><p>1、gulp 写进项目 package.json 文件的依赖有什么作用<br>方便别人查看你项目中有些什么依赖，而且在项目目录下执行 npm install 命令会安装项目 package.json 中的所有依赖模块，这样就能简化项目的安装程序了，不用一个一个模块去安装啊。</p><p>2、gulp 中着重了解 gulp.task() 如何处理依赖任务是耗时操作或者异步操作的情况。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Jun 18 2019 11:45:34 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;什么是-gulp&quot;&gt;&lt;a href=&quot;#什么是-gulp&quot; class=&quot;headerlink&quot; title=&quot;什么是 gulp&quot;&gt;&lt;/a&gt;什么是 gulp&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://gulpjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gulp&lt;/a&gt; 是一个前端构建工具，它能通过自动执行常见任务，比如编译预处理 CSS ，压缩 JavaScript 和刷新浏览器，来改进网站开发的过程，从而使开发更加快速高效。&lt;/p&gt;&lt;h1 id=&quot;为什么要用-gulp&quot;&gt;&lt;a href=&quot;#为什么要用-gulp&quot; class=&quot;headerlink&quot; title=&quot;为什么要用 gulp&quot;&gt;&lt;/a&gt;为什么要用 gulp&lt;/h1&gt;&lt;p&gt;与 grunt 相比，gulp 无需写一大堆繁杂的配置参数，&lt;a href=&quot;https://github.com/gulpjs/gulp/blob/master/docs/API.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;API&lt;/a&gt;（&lt;a href=&quot;http://www.gulpjs.com.cn/docs/api/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文 API&lt;/a&gt;） 也非常简单，学习起来很容易，而且 gulp 使用的是 nodejs 中 &lt;a href=&quot;https://nodejs.org/api/stream.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stream&lt;/a&gt; 来读取和操作数据，其速度更快。&lt;br&gt;gulp 有庞大的生态圈，且每天都在发展。依靠成千上万可供选择的插件，你可以利用 gulp 自动完成几乎任何事。&lt;/p&gt;&lt;h1 id=&quot;如何使用-gulp&quot;&gt;&lt;a href=&quot;#如何使用-gulp&quot; class=&quot;headerlink&quot; title=&quot;如何使用 gulp&quot;&gt;&lt;/a&gt;如何使用 gulp&lt;/h1&gt;&lt;h2 id=&quot;Installing-Gulp&quot;&gt;&lt;a href=&quot;#Installing-Gulp&quot; class=&quot;headerlink&quot; title=&quot;Installing Gulp&quot;&gt;&lt;/a&gt;Installing Gulp&lt;/h2&gt;&lt;p&gt;新版的 gulp 命令行工具已经改名为 gulp-cli 。&lt;br&gt;如果你之前安装了全局的 gulp 。在使用新的 gulp-cli 之前，执行命令&lt;br&gt;&lt;code&gt;npm rm --global gulp&lt;/code&gt; ，将之前的全局 gulp 卸掉。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="gulp" scheme="http://yoursite.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>AMD，CMD 规范详解</title>
    <link href="http://yoursite.com/2017/03/20/amd-cmd/"/>
    <id>http://yoursite.com/2017/03/20/amd-cmd/</id>
    <published>2017-03-19T19:25:24.000Z</published>
    <updated>2018-10-20T07:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><p>当我们了解了 <a href="https://neveryu.github.io/2017/03/07/commonjs/" target="_blank" rel="noopener">CommonJS</a> 以后，<code>CommonJS</code> 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<br>由于 <code>Node.js</code> 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 <code>CommonJS</code> 规范比较适用。<br>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>第二行 <code>math.add(2, 3)</code>，在第一行 <code>require(&#39;math&#39;)</code> 之后运行，因此必须等 <code>math.js</code> 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>对于浏览器，这是一个大问题，因为模块都放在服务器端。等待时间取决于网速的快慢，可能要等很长时间，浏览器处理“假死”状态。</p><p>因此，浏览器端的模块，不能采用“同步加载”，只能采用“异步加载”。</p><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p><a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a> 则是异步加载模块，允许指定回调函数。因此浏览器端一般采用 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>。<br><code>AMD(Asynchronous module definition)</code>： <span id="inline-green">异步模块定义。</span></p><p>类似的还有 <code>CommonJS Modules/2.0</code> 规范，是 <code>BravoJS</code> 在推广过程中对模块定义的规范化产出。<br><code>CMD(Common module definition)</code>：<span id="inline-blue">通用模块定义。</span></p><p>目前这些规范的实现都能达成<strong>浏览器端模块化开发的目的</strong>。</p><table><thead><tr><th style="text-align:center">服务端JS</th><th style="text-align:center">浏览器端JS</th></tr></thead><tbody><tr><td style="text-align:center">相同的代码需要多次执行</td><td style="text-align:center">代码需要从一个服务器端分发到多个客户端执行</td></tr><tr><td style="text-align:center">CPU 和内存资源是瓶颈</td><td style="text-align:center">宽带是瓶颈</td></tr><tr><td style="text-align:center">加载时从磁盘中加载</td><td style="text-align:center">加载时需要通过网络加载</td></tr></tbody></table><p>AMD 的诞生，就是为了解决这两个问题：<br>1.实现 js 文件的异步加载，避免网页失去响应<br>2.管理模块之间的依赖性，便于代码的编写和维护</p><p>AMD(异步模块定义)主要为前端 JS 的表现指定规范。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><p>AMD 也采用 <a href="https://github.com/amdjs/amdjs-api/wiki/require" target="_blank" rel="noopener">require()</a> 语句加载模块，但是不同于 CommonJS，它要求两个参数：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br></pre></td></tr></table></figure><p></p><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数 callback，则是加载成功之后的回调函数：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>实现 AMD 规范的加载器其实是挺多的，目前，主要有两个 Javascript 库实现了 AMD 规范：<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 和 <a href="https://github.com/cujojs/curl" target="_blank" rel="noopener">curl.js</a>。不过多数人还是用 require.js 。<br>另外如果对 ES6 的模块感兴趣，可以考虑 <a href="http://github.com/hax/my.js" target="_blank" rel="noopener">my.js</a> ，是按照 ES6 草案的 module/loader 规范实现的。</p><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a> 是 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 在推广过程中对模块定义的规范化产出。</p><p>推荐学习 <a href="http://requirejs.org/" target="_blank" rel="noopener">require.js</a>。</p><h2 id="AMD-模块的写法"><a href="#AMD-模块的写法" class="headerlink" title="AMD 模块的写法"></a>AMD 模块的写法</h2><p><a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，采用 AMD 规范。也就是说，模块必须按照 AMD 的规定来写。<br>具体来说，就是模块必须采用特定的 define() 函数来定义。如果一个模块不依赖其他模块。那么可以直接定义在 define() 函数之中。<br>假定现在有一个 math.js 文件，它定义了一个 math 模块。那么，math.js 就要这样写：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　<span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> x+y;</span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　add: add</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>加载方法如下：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</span><br><span class="line">　alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>如果这个模块还依赖其他模块，那么 define() 函数的第一个参数，必须是一个数组，指明该模块的依赖性。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myLib</span>)</span>&#123;</span><br><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　myLib.doSomething();</span><br><span class="line">　&#125;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　foo : foo</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>当 require() 函数加载上面这个模块的时候，就会先加载 myLib.js 文件。</p><h2 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h2><p>理论上，<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，必须是按照 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>、用 define() 函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如 jQuery ）符合 AMD 规范，更多的库并不符合。那么，require.js 是否能够加载非规范的模块呢？<br>回答是可以的。<br>这样的模块在用 require() 加载之前，要先用 require.config() 方法，定义它们的一些特征。<br>举例来说，underscore 和 backbone 这两个库，都没有采用 AMD 规范编写。如果要加载它们的话，必须先定义它们的特征。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">　shim: &#123;</span><br><span class="line">　　<span class="string">'underscore'</span>: &#123;</span><br><span class="line">　　　exports: <span class="string">'_'</span></span><br><span class="line">　　&#125;,</span><br><span class="line">　　<span class="string">'backbone'</span>: &#123;</span><br><span class="line">　　　deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</span><br><span class="line">　　　exports: <span class="string">'Backbone'</span></span><br><span class="line">　　&#125;</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>require.config() 接受一个配置对象，这个对象除了有前面说过的 paths 属性之外，还有一个 shim 属性，专门用来配置不兼容的模块。具体来说，每个模块要定义：<br>（1）exports 值（输出的变量名），表明这个模块外部调用时的名称；<br>（2）deps 数组，表明该模块的依赖性。<br>比如，jQuery 的插件可以这样定义：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shim: &#123;</span><br><span class="line">　<span class="string">'jquery.scroll'</span>: &#123;</span><br><span class="line">　　deps: [<span class="string">'jquery'</span>],</span><br><span class="line">　　exports: <span class="string">'jQuery.fn.scroll'</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">CMD</a> 是 <a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">sea.js</a> 在推广过程中对模块定义的规范化产出。</p><h3 id="CMD-模块定义"><a href="#CMD-模块定义" class="headerlink" title="CMD 模块定义"></a>CMD 模块定义</h3><p>在 CMD 规范中，一个模块就是一个文件。define 是一个全局函数，用来定义模块。<br>define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。<br>factory 为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以定义一个 JSON 数据模块：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;<span class="string">"foo"</span>: <span class="string">"bar"</span>&#125;);</span><br></pre></td></tr></table></figure><p></p><p>也可以通过字符串定义模板模块：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'I am a template.My name is &#123;&#123;name&#125;&#125;.'</span>);</span><br></pre></td></tr></table></figure><p></p><p>factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。<br>factory 是一个函数，有三个参数，function(require, exports, module)<br>1、require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id)<br>2、exports 是一个对象，用来向外提供模块接口<br>3、module 是一个对象，上面存储了与当前模块相关联的一些属性和方法<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 依赖就近书写，什么时候用到什么时候引入</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>建议写一写 SeaJS 的 CMD 规范，与 AMD 非常类似，在国内的影响力非常大，但是个人觉得 SeaJS 比 RequireJS 好很多，另外由于是国人开发的，交流也非常方便，可以看到 github 上的更新、互动非常频繁。</p><h1 id="AMD-与-CMD-的区别"><a href="#AMD-与-CMD-的区别" class="headerlink" title="AMD 与 CMD 的区别"></a>AMD 与 CMD 的区别</h1><p>区别：</p><ol><li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li><li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;当我们了解了 &lt;a href=&quot;https://neveryu.github.io/2017/03/07/commonjs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CommonJS&lt;/a&gt; 以后，&lt;code&gt;CommonJS&lt;/code&gt; 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。&lt;br&gt;由于 &lt;code&gt;Node.js&lt;/code&gt; 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 &lt;code&gt;CommonJS&lt;/code&gt; 规范比较适用。&lt;br&gt;但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础知识</title>
    <link href="http://yoursite.com/2017/03/07/JVM%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/03/07/JVM基础/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-06-18T03:40:05.285Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><p>jvm体系总体分四大块：</p><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul><p>一、java类的加载机制：<a href="http://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">http://www.cnblogs.com/ityouknow/p/5603287.html</a></p><h1 id="1、什么是类的加载"><a href="#1、什么是类的加载" class="headerlink" title="1、什么是类的加载"></a><strong>1、什么是类的加载</strong></h1><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的<strong>方法区</strong>内，然后在<strong>堆区</strong>创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p><img src="C:/Users/user/AppData/Local/YNote/data/huanghy134@163.com/fbfc04915fd4489eb76ccdae8710f80b/2-1913742708.png" alt="wps5F9E.tmp"></p><h1 id="2、类的生命周期"><a href="#2、类的生命周期" class="headerlink" title="2、类的生命周期"></a><strong>2、类的生命周期</strong></h1><p><img src="C:/Users/user/AppData/Local/YNote/data/huanghy134@163.com/e22cd9e498ea4ec5a0b657ea1d9c36a3/9-1443333281.png" alt="wps257C.tmp"></p><p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而<strong>解析</strong>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><ul><li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li><li><p>连接，连接又包含三块内容：验证、准备、初始化。</p><p>1）验证，文件格式、元数据、字节码、符号引用验证；</p><p>2）准备，为类的静态变量分配内存，并将其初始化为默认值；</p><p><em>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</em></p><p>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。*</p></li></ul><p>​ 3）解析，把类中的符号引用转换为直接引用</p><ul><li><p>初始化，为类的静态变量赋予正确的初始值</p><p>​ 1）假如这个类还没有被加载和连接，则程序先加载并连接该类</p><p>​ 2）假如该类的直接父类还没有被初始化，则先初始化其直接父类</p><p>​ 3）假如类中有初始化语句，则系统依次执行这些初始化语句</p></li></ul><p>​ 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><p>​ – 创建类的实例，也就是new的方式</p><p>​ – 访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>​ – 调用类的静态方法</p><p>​ – 反射（如Class.forName(“com.shengsiyuan.Test”)）</p><p>​ – 初始化某个类的子类，则其父类也会被初始化</p><p>​ – Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</p><ul><li>使用，new出对象程序中使用</li><li>卸载，执行垃圾回收</li></ul><p><strong>结束生命周期</strong></p><p>•在如下几种情况下，Java虚拟机将结束生命周期</p><p>– 执行了System.exit()方法</p><p>– 程序正常执行结束</p><p>– 程序在执行过程中遇到了异常或错误而异常终止</p><p>– 由于操作系统出现错误而导致Java虚拟机进程终止</p><h1 id="3、类加载器"><a href="#3、类加载器" class="headerlink" title="3、类加载器"></a><strong>3、类加载器</strong></h1><p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><p><strong>启动类加载器</strong>：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p><p><strong>扩展类加载器</strong>：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p><p><strong>应用程序类加载器</strong>：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><p>1）在执行非置信代码之前，自动验证数字签名。</p><p>2）动态地创建符合用户特定需要的定制化构建类。</p><p>3）从特定的场所取得java class，例如数据库中和网络中。</p><p><strong>JVM类加载机制</strong></p><p><strong>•全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p><p><strong>•父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p><p><strong>•缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。<em>这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</em></p><h1 id="4、类的加载"><a href="#4、类的加载" class="headerlink" title="4、类的加载"></a><strong>4、类的加载</strong></h1><p>类加载有三种方式：</p><p>1、命令行启动应用时候由JVM初始化加载</p><p>2、通过Class.forName()方法动态加载</p><p>3、通过ClassLoader.loadClass()方法动态加载</p><p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p><p>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</p><p>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</p><p><strong>注</strong>：</p><p>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</p><h1 id="5、双亲委派模型"><a href="#5、双亲委派模型" class="headerlink" title="5、双亲委派模型"></a><strong>5、双亲委派模型</strong></h1><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>双亲委派机制:</p><p>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p><p>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p><p>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</p><p>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p><p>双亲委派模型意义：</p><p>-系统类防止内存中出现多份同样的字节码</p><p>-保证Java程序安全稳定运行</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;jvm体系总体分四大块：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;类的加载机制&lt;/li&gt;&lt;li&gt;jvm内存结构&lt;/li&gt;&lt;li&gt;GC算法 垃圾回收&lt;/li&gt;&lt;li
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化</title>
    <link href="http://yoursite.com/2017/03/07/2018-06-30-MySQL%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/03/07/2018-06-30-MySQL优化/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-15T04:10:29.485Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java面试</title>
    <link href="http://yoursite.com/2017/03/07/Java%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2017/03/07/Java面试/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-06-18T03:24:24.445Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h1 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h1><p>1、懒汉式（线程不安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、懒汉式（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、饿汉式（更新）</p><h1 id="二、线程池的原理及实现"><a href="#二、线程池的原理及实现" class="headerlink" title="二、线程池的原理及实现"></a>二、线程池的原理及实现</h1><h1 id="三、finally一定会被执行吗？"><a href="#三、finally一定会被执行吗？" class="headerlink" title="三、finally一定会被执行吗？"></a>三、finally一定会被执行吗？</h1><p>答案是错的。有两种情况finally不会被执行</p><p>1、try代码块之前就结束了方法，比如报异常，return出去了</p><p>2、try代码块中，出现System.exit(0)，退出当前Java虚拟机，一旦退出Java虚拟机，任何代码都不会再执行</p><p>3、如果当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行</p><p>4、极端的情况是：就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。</p><p>如果在try，catch代码块中有<strong>return语句</strong>，try、catch、finally的执行顺序又是怎样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"main 代码块中的执行结果为："</span> + myMethod());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"try 代码块被执行！"</span>);</span><br><span class="line"><span class="comment">// i = i/0;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">"catch 代码块被执行！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"finally 代码块被执行！"</span>);</span><br><span class="line">            <span class="comment">//return 3；</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//顺序是try  finally  main1</span></span><br><span class="line"><span class="comment">//如果放开注释  i = i / 0 ，执行顺序为try  catch  finally main2</span></span><br><span class="line"><span class="comment">//如果放开注释  return 3 ，注释i = i / 0，执行顺序为 try finally main3</span></span><br></pre></td></tr></table></figure><p><strong>综上所述</strong>：finally块里面的代码也是在return前执行的。此外，如果try-finally或者catch-finally中都有return，那么finally块中的return语句将会覆盖别处的return语句，最终返回调用者那里的是finally中return的值。因为finally会把try或者catch代码块中的<strong>返回值保留</strong>，再来执行finally代码块中的语句，等到finally代码块执行完毕之后，在把之前<strong>保留的返回值给返回出去</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"try 代码块被执行！"</span>);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">            <span class="comment">//return num();</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">++i;</span><br><span class="line">System.out.println(<span class="string">"finally 代码块被执行！"</span>);</span><br><span class="line">System.out.println(<span class="string">"finally 代码块中的i = "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种情况下，finally打印出来的是2，但是 try 中return 的值还是1</span></span><br><span class="line"><span class="comment">//但还有一种特殊情况，就是try return的时候是调用一个方法的，我们可以这样子理解</span></span><br><span class="line"><span class="comment">//return num() 等同于 int sum = num(); return sum; 执行顺序是 try  num finally main</span></span><br></pre></td></tr></table></figure><h1 id="四、ArrayList、LinkedList、Vector的区别是啥"><a href="#四、ArrayList、LinkedList、Vector的区别是啥" class="headerlink" title="四、ArrayList、LinkedList、Vector的区别是啥"></a>四、ArrayList、LinkedList、Vector的区别是啥</h1><p><img src="https://note.youdao.com/yws/api/personal/file/F67FABE2E7C641BCA5E1EF9A8DE789F6?method=download&amp;shareKey=cf883d57b6e9041be2192213170082fc" alt></p><ul><li><p><strong>ArrayList</strong> 就是<strong>动态数组</strong>（线性表），是Array的复杂版本，动态的增加和减少元素。当更多的元素加入到ArrayList中时，其大小将会动态地增长。它的元素可以通过get/set方法直接访问，因为ArrayList本质上是一个数组。</p><p>但ArrayList随机get/set快 add/remove慢，ArrayList里面维护了一个数组，add时：检查数组的大小是否足够，如果不够将创建一个尺寸扩大一倍新数组，将原数组的数据拷贝到新数组中，原数组丢弃，这里会很慢</p></li><li><p><strong>Vector</strong> 和ArrayList类似, 区别在于Vector是同步类(synchronized).因此,开销就比ArrayList要大。</p></li><li><p><strong>LinkedList</strong> 是一个<strong>链表</strong>，在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比。它还实现了 <strong>Queue</strong> 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等.</p></li></ul><blockquote><p>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</p><p>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据，如果是在末位添加元素，则两者差别不大；如果是在首位添加，ArrayList就要将所有元素后移一位。</p></blockquote><h1 id="五、分布式消息队列，挂掉怎么处理没推送成功的信息信息"><a href="#五、分布式消息队列，挂掉怎么处理没推送成功的信息信息" class="headerlink" title="五、分布式消息队列，挂掉怎么处理没推送成功的信息信息"></a>五、分布式消息队列，挂掉怎么处理没推送成功的信息信息</h1><h1 id="六、微服务通讯协议-、序列化"><a href="#六、微服务通讯协议-、序列化" class="headerlink" title="六、微服务通讯协议 、序列化"></a>六、微服务通讯协议 、序列化</h1><h1 id="七、为什么公司项目用dubbo，不用springclould"><a href="#七、为什么公司项目用dubbo，不用springclould" class="headerlink" title="七、为什么公司项目用dubbo，不用springclould"></a>七、为什么公司项目用dubbo，不用springclould</h1><p>dubbo和spring cloud的优缺点吗，说完后结合自己的场景说明就可以了</p><table><thead><tr><th></th><th>Spring Cloud</th><th>dubbo</th></tr></thead><tbody><tr><td>框架原理</td><td>基于Http协议+rest接口调用远程过程的</td><td>使用Netty这样的NIO框架，是基于TCP协议传输的，配合以Hession序列化完成RPC</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="八、hashmap冲突的解决方法以及原理分析"><a href="#八、hashmap冲突的解决方法以及原理分析" class="headerlink" title="八、hashmap冲突的解决方法以及原理分析"></a>八、hashmap冲突的解决方法以及原理分析</h1><p>HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。当程序执行<br>map.put(String,Obect)方法 时，系统将调用String的 hashCode() 方法得到其 hashCode 值——每个<br>Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode<br>值之后，系统会根据该 hashCode 值来决定该元素的存储位置。</p><p><a href="https://www.cnblogs.com/peizhe123/p/5790252.html" target="_blank" rel="noopener">hashmap冲突的解决方法以及原理分析</a></p><h1 id="九、hashmap的死循环"><a href="#九、hashmap的死循环" class="headerlink" title="九、hashmap的死循环"></a>九、hashmap的死循环</h1><h1 id="十、框架问题"><a href="#十、框架问题" class="headerlink" title="十、框架问题"></a>十、框架问题</h1><h2 id="10-1、hibernate跟Mybatis-的区别"><a href="#10-1、hibernate跟Mybatis-的区别" class="headerlink" title="10.1、hibernate跟Mybatis 的区别"></a>10.1、hibernate跟Mybatis 的区别</h2><p><strong>来源：</strong>Hibernate 是当前最流行的O/R mapping框架，它出身于sf.net，现在已经成为Jboss的一部分。 Mybatis 是另外一种优秀的O/R mapping框架。目前属于apache的一个子项目。</p><p>区别：</p><table><thead><tr><th></th><th>Hibernate</th><th>Mybatis</th></tr></thead><tbody><tr><td></td><td>POJO 到数据库表的映射关系</td><td>POJO 与SQL之间的映射关系</td></tr><tr><td>开发速度</td><td>简单CRUD，效率较快，基本sql封装好</td><td>复杂语句校多</td></tr><tr><td>开发工作量</td><td>良好的映射机制，无需关心SQL生成与结果映射</td><td>高级查询，手动编写SQL和ResultMap，需要维护SQL和结果映射</td></tr><tr><td>sql优化</td><td>所有字段查出，性能消耗；可用HQL，破坏开发简洁性</td><td>按需求指定查询的字段</td></tr><tr><td>对象管理</td><td>关注对象的状态，不考虑SQL语句的执行</td><td>需要对对象进行详细的管理</td></tr><tr><td>缓存</td><td>Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。</td><td>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</td></tr><tr><td>移植性</td><td>数据库无关性好</td><td>需要根据不同数据库，设置不同的SQL语句</td></tr></tbody></table><h1 id="十一、数据库"><a href="#十一、数据库" class="headerlink" title="十一、数据库"></a>十一、数据库</h1><h2 id="11-1、乐观锁和悲观锁的实现"><a href="#11-1、乐观锁和悲观锁的实现" class="headerlink" title="11.1、乐观锁和悲观锁的实现"></a>11.1、乐观锁和悲观锁的实现</h2><h2 id="11-2、什么情况索引不会命中，会造成全表扫描"><a href="#11-2、什么情况索引不会命中，会造成全表扫描" class="headerlink" title="11.2、什么情况索引不会命中，会造成全表扫描"></a>11.2、什么情况索引不会命中，会造成全表扫描</h2><h1 id="十二、Java基础"><a href="#十二、Java基础" class="headerlink" title="十二、Java基础"></a>十二、Java基础</h1><h2 id="12-1、面向对象编程有三大特性有哪些"><a href="#12-1、面向对象编程有三大特性有哪些" class="headerlink" title="12.1、面向对象编程有三大特性有哪些?"></a>12.1、面向对象编程有三大特性有哪些?</h2><p>面向对象编程有三大特性：封装、继承、多态。</p><ul><li><p>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。</p></li><li><p>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。</p></li><li>多态</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;一、单例模式&quot;&gt;&lt;a href=&quot;#一、单例模式&quot; class=&quot;headerlink&quot; title=&quot;一、单例模式&quot;&gt;&lt;/a&gt;一、单
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker数据管理</title>
    <link href="http://yoursite.com/2017/03/07/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/03/07/Docker数据管理/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-11T03:19:05.330Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h2 id="Docker数据管理"><a href="#Docker数据管理" class="headerlink" title="Docker数据管理"></a>Docker数据管理</h2><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个或多个容器专门指定绕过Union File System的特殊目录，为持续性或共享数据提供一些有用的功能。数据卷可以用来存储Docker应用的数据，也可以用来在Docker容器间进行数据共享。 使用Docker的数据卷，类似在系统中使用 mount 挂载一个文件系统</p><ul><li>数据卷可以在容器间共享和重用</li><li>数据卷数据改变是直接修改的</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷是持续性的，直到没有容器使用它们</li></ul><h4 id="添加一个数据卷"><a href="#添加一个数据卷" class="headerlink" title="添加一个数据卷"></a>添加一个数据卷</h4><p>使用 -v 选项添加一个数据卷，或者可以使用多次 -v 选项为一个 docker 容器运行挂载多个数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>加载数据卷到容器的/webapp目录</span><br><span class="line">sudo docker run -d -P --name web -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure><h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><p>数据卷是独立于容器，Docker不会在容器被删除后自动删除数据卷，也不会有垃圾回收机制来处理。如果要删除数据卷，可以在删除容器的时候，加个 -v 的选项。</p><h4 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h4><p>挂载是啥意思啊？答：挂载就是把设备放在一个目录下，用U盘例子理解一下哦~</p><p>可以直接挂载宿主机文件或目录(设备)到容器(目录)里，可以理解为目录映射，这样就可以让所有的容器共享宿主机数据，从而只需要改变宿主机的数据源就能够影响到所有的容器数据。</p><p>挂载的数据默认为可读写权限。 :ro 为挂载的数据为只读</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>-v后面的映射关系是"宿主机文件/目录:容器里对应的文件/目录"，其中，宿主机上的文件/目录是要提前存在的，容器里对应的文件/目录会自动创建。 </span><br><span class="line">docker run -t -i --name test -v /src/webapp/1.txt:/opt/webapp/1.txt:ro docker.io/centos /bin/bash</span><br><span class="line">docker run -t -i --name hqsb -v /src/webapp:/opt/webapp docker.io/centos /bin/bash</span><br></pre></td></tr></table></figure><h4 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect web</span><br></pre></td></tr></table></figure><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>数据卷容器，其实是一个正常的容器，专门用来提供数据卷供其它容器挂载的。</p><p>用户需要在多个容器之间共享一些持续更新的数据，最好用数据卷容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建数据卷容器</span><br><span class="line">docker run -d -v /dbdata --name dbdata training/postgres</span><br><span class="line"><span class="meta">#</span>使用 --volumes-from 来挂载容器中的数据卷</span><br><span class="line">docker run -d --volumes-from dbdata --name db1 training/postgres</span><br><span class="line"></span><br><span class="line">docker run -d --name db3 --volumes-from db1 training/postgres</span><br></pre></td></tr></table></figure><h4 id="利用数据卷容器来迁移数据"><a href="#利用数据卷容器来迁移数据" class="headerlink" title="利用数据卷容器来迁移数据"></a>利用数据卷容器来迁移数据</h4><p>可以利用数据卷容器对其中的数据卷进行备份、恢复，以实现数据的迁移。</p><ol><li><h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><p>首先利用ubuntu镜像创建了一个容器worker。使用–volumes-from dbdata参数来让worker容器挂载dbdata容器的数据卷(即dbdata数据卷),使用-v $(pwd):/backup参数来挂载本地的当前目录到worker容器的/backup目录。worker容器启动后，使用了tar cvf /backup/backup.tar /dbdata命令来将/dbdata下内容备份为容器内的/backup/backup.tar，即宿主主机当前目录下的backup.tar。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from dbdata -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdata</span><br></pre></td></tr></table></figure></li><li><h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><p>首先创建一个带有数据卷的容器dbdata2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>然后创建另一个新的容器，挂载dbdata2的容器，并使用untar解压备份文件到所挂载的容器卷中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from dbdata2 -v $(pwd):/backup --name worker ubuntu tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Docker数据管理&quot;&gt;&lt;a href=&quot;#Docker数据管理&quot; class=&quot;headerlink&quot; title=&quot;Docker数
      
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（五）：Spring Cloud Zuul</title>
    <link href="http://yoursite.com/2017/03/07/Spring%20Cloud%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1Spring%20Cloud%20Zuul/"/>
    <id>http://yoursite.com/2017/03/07/Spring Cloud（五）：网关路由Spring Cloud Zuul/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-06-18T03:23:46.673Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h1 id="一、什么是Spring-Cloud-Zuul？"><a href="#一、什么是Spring-Cloud-Zuul？" class="headerlink" title="一、什么是Spring Cloud Zuul？"></a>一、什么是Spring Cloud Zuul？</h1><p>Zuul作为路由网关组件，将所有服务的API接口统一聚合，并且一起对外暴露。（路由转发和过滤器）外界不用知道内部的各个服务相互调用的复杂性，从而保护了内部微服务单元的API接口，防止被外界直接调用，导致服务的敏感信息暴露。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器</p><p><img src="https://note.youdao.com/yws/api/personal/file/A987B794E9974665AE54954733F623B7?method=download&amp;shareKey=a7ab1832575b4659f6b5fb8a98ce65f7" alt></p><h1 id="二、为什么需要API-Gateway"><a href="#二、为什么需要API-Gateway" class="headerlink" title="二、为什么需要API Gateway"></a>二、为什么需要API Gateway</h1><p>1、简化客户端调用复杂度</p><p>​ 实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度</p><p>2、数据裁剪以及聚合</p><p>​ 对通用性的响应数据进行裁剪以适应不同客户端的使用需求，可以将多个API调用逻辑进行聚合，减少客户端的请求数，优化客户端用户体验</p><p>3、多渠道支持</p><h1 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h1><p>Zuul是通过Servlet实现的，通过自定义的ZuulServlet（这一点有点像springmvc的dispatchServlet）来对请求进行控制。ZuulServlet 的作用是初始化ZuulFilter，并编排这些ZuulFilter 的执行顺序。Zuul的核心就是一堆的过滤器，可以在Http请求和响应执行一堆过滤器。</p><p><strong>大概流程应该是这样的</strong>：当一个客户端Request 请求进入Zuul 网关服务时，网关先进入“<strong>pre filter</strong>”，进行一系列的验证、操作或者判断。然后给“<strong>routing filter</strong> ”进行路由转发，转发到具体的服务实例进行逻辑处理、返回数据。当具体的服务处理完后，最后由“<strong>post filter</strong> “进行处理， 该类型的处理器处理完之后，将Response 信息返回给客户端。</p><h1 id="四、准备工作"><a href="#四、准备工作" class="headerlink" title="四、准备工作"></a>四、准备工作</h1><p>通过配置文件我们知道，Spring Cloud Zuul 将自己作为一个服务注册到了Eureka。这也就意味着Zuul可以拿到所有注册到Eureka的其他服务的信息。Zuul为这些服务创建了默认的路由规则：<strong>/{servicename}/**</strong></p><p>POM 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-1、配置文件"><a href="#4-1、配置文件" class="headerlink" title="4.1、配置文件"></a>4.1、配置文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    hiapi:</span>  <span class="comment">#自己定义的</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/hiapi/**</span>    <span class="comment">#就可以将指定类型的请求Uri 路由到指定的Serviceld</span></span><br><span class="line"><span class="attr">      serviceid:</span> <span class="string">eureka-client</span></span><br><span class="line"><span class="attr">    ribbonapi:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/ribbonapi/**</span></span><br><span class="line"><span class="attr">      serviceid:</span> <span class="string">eureka-ribbon-client</span></span><br><span class="line"><span class="attr">    feignapi:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/feignapi/**</span></span><br><span class="line">      <span class="string">serviceid</span> <span class="string">:</span> <span class="string">eureka-feign-client</span></span><br></pre></td></tr></table></figure><h2 id="4-2、启动类"><a href="#4-2、启动类" class="headerlink" title="4.2、启动类"></a>4.2、启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3、网关的默认路由规则"><a href="#4-3、网关的默认路由规则" class="headerlink" title="4.3、网关的默认路由规则"></a>4.3、网关的默认路由规则</h2><p>Zuul的路由的默认规则为：<code>http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**</code>，会被转发到serviceId对应的服务</p><h1 id="五、服务过滤"><a href="#五、服务过滤" class="headerlink" title="五、服务过滤"></a>五、服务过滤</h1><p>Filter是Zuul的核心，用来实现对外服务的控制。Filter的生命周期有4个，分别是“PRE”、“ROUTING”、“POST”、“ERROR”，整个生命周期可以用下图来表示。</p><ul><li><strong>PRE：</strong> 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</li><li><strong>ROUTING：</strong>这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。</li><li><strong>POST：</strong>这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</li><li><strong>ERROR：</strong>在其他阶段发生错误时执行该过滤器。 除了默认的过滤器类型，Zuul还允许我们创建自定义的过滤器类型。例如，我们可以定制一种STATIC类型的过滤器，直接在Zuul中生成响应，而不将请求转发到后端的微服务。</li></ul><h2 id="5-1、Zuul中默认实现的Filter"><a href="#5-1、Zuul中默认实现的Filter" class="headerlink" title="5.1、Zuul中默认实现的Filter:"></a>5.1、Zuul中默认实现的Filter:</h2><table><thead><tr><th>类型</th><th>顺序</th><th>过滤器</th><th>功能</th></tr></thead><tbody><tr><td>pre</td><td>-3</td><td>ServletDetectionFilter</td><td>标记处理Servlet的类型</td></tr><tr><td>pre</td><td>-2</td><td>Servlet30WrapperFilter</td><td>包装HttpServletRequest请求</td></tr><tr><td>pre</td><td>-1</td><td>FormBodyWrapperFilter</td><td>包装请求体</td></tr><tr><td>route</td><td>1</td><td>DebugFilter</td><td>标记调试标志</td></tr><tr><td>route</td><td>5</td><td>PreDecorationFilter</td><td>处理请求上下文供后续使用</td></tr><tr><td>route</td><td>10</td><td>RibbonRoutingFilter</td><td>serviceId请求转发</td></tr><tr><td>route</td><td>100</td><td>SimpleHostRoutingFilter</td><td>url请求转发</td></tr><tr><td>route</td><td>500</td><td>SendForwardFilter</td><td>forward请求转发</td></tr><tr><td>post</td><td>0</td><td>SendErrorFilter</td><td>处理有错误的请求响应</td></tr><tr><td>post</td><td>1000</td><td>SendResponseFilter</td><td>处理正常的请求响应</td></tr></tbody></table><p>禁用Filter</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">FormBodyWrapperFilter:</span></span><br><span class="line"><span class="attr">pre:</span></span><br><span class="line"><span class="attr">disable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="5-2、自定义Filter"><a href="#5-2、自定义Filter" class="headerlink" title="5.2、自定义Filter"></a>5.2、自定义Filter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(MyFilter.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：</span></span><br><span class="line"><span class="comment">    pre：路由之前</span></span><br><span class="line"><span class="comment">    routing：路由之时</span></span><br><span class="line"><span class="comment">    post： 路由之后</span></span><br><span class="line"><span class="comment">    error：发送错误调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//filterOrder：过滤的顺序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line">        log.info(String.format(<span class="string">"%s &gt;&gt;&gt; %s"</span>, request.getMethod(), request.getRequestURL().toString()));</span><br><span class="line">        Object accessToken = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(accessToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"token is empty"</span>);</span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ctx.getResponse().getWriter().write(<span class="string">"token is empty"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"ok"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.2、</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;一、什么是Spring-Cloud-Zuul？&quot;&gt;&lt;a href=&quot;#一、什么是Spring-Cloud-Zuul？&quot; class=&quot;
      
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://yoursite.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（二）：服务治理Eureka</title>
    <link href="http://yoursite.com/2017/03/07/Spring%20Cloud%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86Eureka/"/>
    <id>http://yoursite.com/2017/03/07/Spring Cloud（二）：服务治理Eureka/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-11T03:25:10.747Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --><h2 id="什么是Spring-Cloud-Eureka？"><a href="#什么是Spring-Cloud-Eureka？" class="headerlink" title="什么是Spring Cloud Eureka？"></a>什么是Spring Cloud Eureka？</h2><p>Spring Cloud Eureka 是 Spring Cloud Netflix微服务套件中的一部分，是在Eureka开源组件进一步封装。服务中心又称注册中心，管理各种服务功能包括服务的注册、发现、熔断、负载、降级等，比如dubbo admin后台的各种功能。</p><p>Eureka 是一个基于 REST 的服务，主要在 AWS 云中使用, 定位服务来进行中间层服务器的负载均衡和故障转移。</p><p>Eureka的基本架构有三种角色。</p><ul><li><p><strong>Register Service:服务注册中心</strong>，它是一个Eureka Server，提供服务注册和发现的功能</p><ul><li>失效剔除</li></ul><p><u>Eureka Server在启动的时候会创建一个定时任务，默认每隔30秒将当前清单中超时90秒没有续约的服务剔除出去。</u></p><ul><li>自我保护</li></ul><p><u>服务注册到Eureka Server后，会维护一个心跳连接。Eureka Server在运行期间，会统计心跳失败的比例在15分钟内是否低于85%，如果出现低于的情况，Eureka Server 会将当前的实例注册信息保护起来，让这些实例不会过期。</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>Provider Service:服务提供者</strong>，它是一个Eureka Client，提供服务</p><ul><li>服务注册</li></ul><p><u>“服务提供者”启动的时候发送REST请求将自己注册到Eureka Server，同时带上自身的元数据信息。Eureka Server接收到REST请求后，将元数据存储到一个双层结构Map中，第一层的key是服务名，第二层key是具体服务的实例名。</u></p><ul><li>服务同步</li></ul><p><u>由于服务注册中心之间因互相注册为服务，当服务提供者发送注册请求到一个服务注册中心，它会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。</u></p><ul><li>服务续约</li></ul><p><u>注册完服务之后，服务提供者会维护一个心跳用来持续告诉Eureka Server，我还活着，防止Eureka Server 剔除任务将服务实例从服务列表中排除出去</u>。</p></li><li><p><strong>Comsumer Service:服务消费者</strong>，它是一个Eureka Client，消费服务</p><ul><li>获取服务</li></ul><p><u>启动服务消费者，它发送一个REST请求给服务注册中心，获取注册服务清单。Eureka Server会维护一份只读的服务清单返回给客户端，同时清单会每隔30秒更新一次。</u></p><ul><li>服务调用</li></ul><p><u>服务消费者在获取服务清单后，通过服务名可以获取具体服务的实例名和实例的元数据信息。（每个服务客户端需要注册到一个Zone中，每个客户端对应一个Region和一个Zone。在服务调用的时候，优先访问同处一个Zone的服务提供方，如果访问不到，就访问其他Zone）</u></p><ul><li>服务下线</li></ul><p><u>当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，服务端接收到请求后，将该服务状态设置为下线（DOWN），并把下线的事件传播出去。</u></p></li></ul><p>服务流程是先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行</p><h2 id="什么是服务治理？"><a href="#什么是服务治理？" class="headerlink" title="什么是服务治理？"></a>什么是服务治理？</h2><p>服务治理是微服务架构中最为核心和基础的模块，它主要用来实现各个微服务实例的自动化注册与发现。</p><p><img src="https://note.youdao.com/yws/api/personal/file/C8F0E49F8A384402B440C63AC6F5D81D?method=download&amp;shareKey=59c1b82b4243a9f5bd812f8f8b6bca5e" alt="1534400474739"></p><ul><li>服务注册</li></ul><p>在服务治理的框架中，通常会构建一个服务注册中心，每个服务单元向注册中心登记自己提供的服务，将主机与端口好、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务名单。服务注册中心还需要以==心跳的方式==去检测清单中的服务是否可用，若不可用需要从服务清单中剔除掉。</p><ul><li>服务发现</li></ul><p>服务间的调用是通过向服务名发起请求调用实现。调用方向服务注册中心咨询服务，并获得所有服务的实例清单，以实现对具体服务实例的访问。当服务发起调用的时候，就从这份清单用某种轮询策略去除一个位置来进行服务调用。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>搭建服务注册中心</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   <span class="comment">&lt;!--这个springboot2.x以上，springcloud指定的版本--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">  <span class="comment">#代表不向注册中心注册自己</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>   </span><br><span class="line">    <span class="comment">#注册中心是维护服务实例，不需要去检索服务</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span>   </span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="高可用注册中心（集群）"><a href="#高可用注册中心（集群）" class="headerlink" title="高可用注册中心（集群）"></a>高可用注册中心（集群）</h2><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>application.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-ha</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer2:8762/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">eureka-ha</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>电脑配置：</p><p>因为是在本地搭建Eureka Server 集群，所以需要修改本地的host o Windows 系统的电脑<br>在C: /windows/system32/drivers/etc/hosts 中修改， Mac 系统的电脑通过终端vim/etc/hosts 进行编<br>辑修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 peer1</span><br><span class="line">127.0.0.1 peer2</span><br></pre></td></tr></table></figure><p>启动peer1,peer2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar xx.jar --spring.profiles.active=peer1</span><br><span class="line">java -jar xx.jar --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jun 18 2019 11:45:33 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;什么是Spring-Cloud-Eureka？&quot;&gt;&lt;a href=&quot;#什么是Spring-Cloud-Eureka？&quot; class=&quot;
      
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://yoursite.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
</feed>
