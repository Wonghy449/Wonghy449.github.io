<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-15T03:49:23.139Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Huayan Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot日志</title>
    <link href="http://yoursite.com/2019/04/15/2018-7-5-SpringBoot%E4%B9%8B%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2019/04/15/2018-7-5-SpringBoot之日志/</id>
    <published>2019-04-15T03:46:00.292Z</published>
    <updated>2019-04-15T03:49:23.139Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之注解类</title>
    <link href="http://yoursite.com/2019/04/15/2018-7-2-SpringBoot%E4%B9%8B%E6%B3%A8%E8%A7%A3%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/04/15/2018-7-2-SpringBoot之注解类/</id>
    <published>2019-04-15T03:46:00.286Z</published>
    <updated>2019-04-15T03:49:23.093Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><h4 id="1、-ConfigurationProperties和-Value的区别"><a href="#1、-ConfigurationProperties和-Value的区别" class="headerlink" title="1、@ConfigurationProperties和@Value的区别"></a>1、@ConfigurationProperties和@Value的区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "author")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;bean class="User"&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="name" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取/#&#123;spEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>@Value用法：等同于上面的<property>中的value赋值</property></p><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">@ConfigurationProperties</th><th style="text-align:center">@Value</th></tr></thead><tbody><tr><td style="text-align:center">功能</td><td style="text-align:center">批量注入配置文件中的属性</td><td style="text-align:center">一个个指定</td></tr><tr><td style="text-align:center">松散绑定（松散语法）</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">SpEL</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">JSR303数据校验（@Email等）</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr></tbody></table><p>如果说，只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value<br>如果说，专门编写一个javaBean来和配置文件进行映射，使用@ConfigurationProperties</p><h4 id="2、-PropertySource-amp-ImportSource"><a href="#2、-PropertySource-amp-ImportSource" class="headerlink" title="2、@PropertySource&amp;@ImportSource"></a>2、@PropertySource&amp;@ImportSource</h4><p>@PropertySource:加载指定的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "author")</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br></pre></td></tr></table></figure><p>@ImportSource：导入Spring的配置文件，让配置文件里面的内容生效</p><p>在Spring Boot中，对于我们自己编写的配置文件，是不能自动识别的；</p><p>想让Spring的配置文件生效，加载进去；需要将<strong>@ImportSource</strong>加载配置类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportSource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure><p>SpringBoot推荐给容器中添加组件的方式：推荐全注解<br>1、配置类，使用@Configuration设置为配置类<br>2、使用@Bean给容器添加组件<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将方法中的返回值添加到容器中，容器中这种组件的id为方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloServiceImpl <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>3、</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;1、-ConfigurationProperties和-Value的区别&quot;&gt;&lt;a href=&quot;#1、-ConfigurationPro
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之配置文件</title>
    <link href="http://yoursite.com/2019/04/15/2018-7-2-SpringBoot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/04/15/2018-7-2-SpringBoot之配置文件/</id>
    <published>2019-04-15T03:46:00.279Z</published>
    <updated>2019-04-15T03:49:23.264Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><h4 id="1、YAML语法："><a href="#1、YAML语法：" class="headerlink" title="1、YAML语法："></a><strong>1、YAML语法：</strong></h4><h4 id="2、配置文件值注入"><a href="#2、配置文件值注入" class="headerlink" title="2、配置文件值注入"></a><strong>2、配置文件值注入</strong></h4><h4 id="3、配置文件占位符"><a href="#3、配置文件占位符" class="headerlink" title="3、配置文件占位符"></a><strong>3、配置文件占位符</strong></h4><h5 id="1、随机数"><a href="#1、随机数" class="headerlink" title="1、随机数"></a>1、随机数</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;</span><br><span class="line">$&#123;random.int(10)&#125;、$random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure><h5 id="2、占位符获取前面配置的值，如果没有可以用-（冒号）-指定默认值"><a href="#2、占位符获取前面配置的值，如果没有可以用-（冒号）-指定默认值" class="headerlink" title="2、占位符获取前面配置的值，如果没有可以用 :（冒号） 指定默认值"></a>2、占位符获取前面配置的值，如果没有可以用 :（冒号） 指定默认值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.lastName=hhy</span><br><span class="line">person.dog.name=$&#123;person.hello:hello&#125;_dog</span><br></pre></td></tr></table></figure><h4 id="4、Profile多环境配置"><a href="#4、Profile多环境配置" class="headerlink" title="4、Profile多环境配置"></a>4、Profile多环境配置</h4><h5 id="1、多Profile文件"><a href="#1、多Profile文件" class="headerlink" title="1、多Profile文件"></a>1、多Profile文件</h5><p>application-{profile}.properties/yml</p><p>默认使用application.properties文件</p><h5 id="2、yml支持多文档块方式"><a href="#2、yml支持多文档块方式" class="headerlink" title="2、yml支持多文档块方式"></a>2、yml支持多文档块方式</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8083</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8084</span></span><br></pre></td></tr></table></figure><h5 id="3、激活使用profile"><a href="#3、激活使用profile" class="headerlink" title="3、激活使用profile"></a>3、激活使用profile</h5><p>​ 1、在配置文件中指定 spring.profiles.active=dev</p><p>​ 2、命令行：–spring.profiles.active=dev</p><p>​ 在run/debug Confgurations中Program arguments中填写–spring.profiles.active=dev</p><p>​ 在cmd中，java -jar xxxx.jar –spring.profiles.active=dev</p><p>​ 3、虚拟机参数：</p><p>​ 在run/debug Confgurations中VM options中填写:</p><p>​ -Dspring.profiles.active=dev</p><h4 id="5、配置文件加载位置"><a href="#5、配置文件加载位置" class="headerlink" title="5、配置文件加载位置"></a>5、配置文件加载位置</h4><p>Spring boot启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><p>file: ./config/ 根路径的文件夹</p><p>file: ./</p><p>classpath: ./config/ 类路径的config文件夹</p><p>classpath: /</p><p>优先级由高到低，高优先级的配置会覆盖低优先级的配置</p><p>Spring boot 会从四个位置全部加载主配置文件：<strong>互补配置</strong></p><p>在运维的时候比较方便：</p><p>可以通过<strong>spring.config.location</strong>来改变配置</p><p>项目已经打包好了，我可以使用<strong>命令行参数</strong>的形式（–spring.config.location=xxxx），启动项目的时候指定配置文件的新位置；指定配置文件和默认加载的配置文件共同起作用形成<strong>互补配置</strong></p><h4 id="6、外部配置加载顺序"><a href="#6、外部配置加载顺序" class="headerlink" title="6、外部配置加载顺序"></a>6、外部配置加载顺序</h4><p><strong>优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p><p><strong>1.命令行参数</strong><br>所有的配置都可以在命令行上进行指定<br>java -jar xxx.jar –server.port=8087 –server.context-path=/abc<br>多个配置用空格分开 –配置项=值<br>2.来自java:comp/env的JNDI属性<br>3.Java系统属性（System.getProperties()）<br>4.操作系统环境变量<br>5.RandomValuePropertySource配置的random.*属性值</p><p>由<strong>jar包外向jar包内</strong>进行寻找；</p><p>==<strong>优先加载带profile</strong>==<br><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong><br><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p>==<strong>再来加载不带profile</strong>==<br><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong><br><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource<br>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；<br><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><h4 id="7、自动配置原理"><a href="#7、自动配置原理" class="headerlink" title="7、自动配置原理"></a>7、自动配置原理</h4><p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><ol><li>Spring Boot 启动的时候加载主配置类，开启自动配置功能==@EnableAutoConfiguration==</li><li>==@EnableAutoConfiguration==的作用：</li></ol><p>精髓：</p><p>xxxAutoConfiguration：自动配置类</p><p>给容器添加组件</p><p>xxxProperties：<strong>封装</strong>配置文件中相关属性（如果我们对自动配置类中哪些属性 不满意，可以通过在配置文件中配置）</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;1、YAML语法：&quot;&gt;&lt;a href=&quot;#1、YAML语法：&quot; class=&quot;headerlink&quot; title=&quot;1、YAML语法：
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot之基础准备</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-14-SpringBoot%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-14-SpringBoot基础准备/</id>
    <published>2019-04-15T03:46:00.266Z</published>
    <updated>2019-04-15T03:49:23.239Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><h2 id="SpringBoot是什么？"><a href="#SpringBoot是什么？" class="headerlink" title="SpringBoot是什么？"></a>SpringBoot是什么？</h2><ul><li>简化Spring应用开发的一个框架；</li><li>整个Spring技术栈的大集合；</li><li>J2EEE开发的一站式解决方案<h2 id="SpringBoot优缺点？"><a href="#SpringBoot优缺点？" class="headerlink" title="SpringBoot优缺点？"></a>SpringBoot优缺点？</h2></li><li>快速创建独立运行的Spring项目和主流框架的继承</li><li>使用嵌入式的Servlet容器，应用无需打包成war包，直接打包成jar包，使用java -jar命令执行</li><li>starters自动依赖与版本控制</li><li>大量自动配置，简化开发，也可修改默认值</li><li>无需配置xml</li><li>生产环境的运行时应用监控</li><li>与云计算的天然合成</li></ul><h2 id="SpringApplication的执行流程"><a href="#SpringApplication的执行流程" class="headerlink" title="SpringApplication的执行流程"></a>SpringApplication的执行流程</h2><p><strong>流程图：</strong><br><img src="https://note.youdao.com/yws/api/personal/file/F8240B8EF72E4749A998B6A085C8490D?method=download&amp;shareKey=7f2f78e525977804bf8fd2b690929c8e" alt="image"></p><p><strong>具体步骤：</strong></p><ol><li>SpringApplication初始化</li><li></li></ol><p>SpringApplicationRunListener</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;SpringBoot是什么？&quot;&gt;&lt;a href=&quot;#SpringBoot是什么？&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>缓存机制</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-07-%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-07-缓存/</id>
    <published>2019-04-15T03:46:00.256Z</published>
    <updated>2019-04-15T03:49:23.069Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:05 GMT+0800 (GMT+08:00) --><h2 id="缓存是什么？"><a href="#缓存是什么？" class="headerlink" title="缓存是什么？"></a>缓存是什么？</h2><h2 id="MyBatis缓存问题："><a href="#MyBatis缓存问题：" class="headerlink" title="MyBatis缓存问题："></a>MyBatis缓存问题：</h2><p>useCache和flushCache这两个选项有点混淆：</p><p>flushCache：如果设成true，当语句调用时一级二级缓存都会被清理掉。select语句默认是false<br>useCache：如果设成true，语句调用的结果会缓存在二级缓存里。select语句默认是true</p><h2 id="第三方缓存："><a href="#第三方缓存：" class="headerlink" title="第三方缓存："></a>第三方缓存：</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:05 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;缓存是什么？&quot;&gt;&lt;a href=&quot;#缓存是什么？&quot; class=&quot;headerlink&quot; title=&quot;缓存是什么？&quot;&gt;&lt;/a&gt;缓存是
      
    
    </summary>
    
      <category term="缓存" scheme="http://yoursite.com/categories/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Git远程仓库</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-06-git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-06-git远程仓库/</id>
    <published>2019-04-15T03:46:00.248Z</published>
    <updated>2019-04-15T03:49:23.217Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><p>用命令行形式来创建一个仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echo "# MyDemo" &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line">git commit -m "first commit"</span><br><span class="line"></span><br><span class="line">git remote add origin https://github.com/Wonghy449/MyDemo.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>从已有的远程仓库克隆一份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:Wonghy449/MyDemo.git</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;用命令行形式来创建一个仓库&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-06-git%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-06-git命令列表/</id>
    <published>2019-04-15T03:46:00.241Z</published>
    <updated>2019-04-15T03:49:23.116Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:05 GMT+0800 (GMT+08:00) --><h2 id="Git的操作"><a href="#Git的操作" class="headerlink" title="Git的操作"></a>Git的操作</h2><p>参考：<a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html#diff" target="_blank" rel="noopener">图解Git命令</a></p><p><strong>日常使用6个命令</strong><br><img src="https://images2017.cnblogs.com/blog/63651/201709/63651-20170905212837976-775285128.png" alt="image"></p><h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下，也可以在项目目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line">#查看系统config</span><br><span class="line">git config --system --list</span><br><span class="line">　　</span><br><span class="line">#查看当前用户（global）配置</span><br><span class="line">git config --global  --list</span><br><span class="line"> </span><br><span class="line">#查看当前仓库配置信息</span><br><span class="line">git config --local  --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend &lt;file1&gt; &lt;file2&gt; ...</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 列出所有本地分支</span><br><span class="line"><span class="meta">$</span> git branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 列出所有远程分支</span><br><span class="line"><span class="meta">$</span> git branch -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 列出所有本地分支和远程分支</span><br><span class="line"><span class="meta">$</span> git branch -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新建一个分支，但依然停留在当前分支</span><br><span class="line"><span class="meta">$</span> git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新建一个分支，并切换到该分支</span><br><span class="line"><span class="meta">$</span> git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新建一个分支，指向指定commit</span><br><span class="line"><span class="meta">$</span> git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line"><span class="meta">$</span> git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 切换到指定分支，并更新工作区</span><br><span class="line"><span class="meta">$</span> git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line"><span class="meta">$</span> git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 合并指定分支到当前分支</span><br><span class="line"><span class="meta">#</span>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</span><br><span class="line"><span class="meta">$</span> git merge [branch]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> git merge --no-ff -m "merge with no-ff" [branch]  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 选择一个commit，合并进当前分支</span><br><span class="line"><span class="meta">$</span> git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除分支</span><br><span class="line"><span class="meta">$</span> git branch -d [branch-name]</span><br><span class="line"><span class="meta">#</span>强制删除没有合并的分支</span><br><span class="line"><span class="meta">$</span> git branch -D [name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除远程分支</span><br><span class="line"><span class="meta">$</span> git push origin --delete &lt;branch-name&gt;</span><br><span class="line"><span class="meta">$</span> git branch -dr &lt;remote/branch&gt;</span><br></pre></td></tr></table></figure><h3 id="储存分支"><a href="#储存分支" class="headerlink" title="储存分支"></a>储存分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>存储当前分支工作现场</span><br><span class="line"><span class="meta">$</span> git stash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看存储的工作现场列表</span><br><span class="line"><span class="meta">$</span> git stash list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>恢复工作现场</span><br><span class="line"><span class="meta">$</span> git stash apply stash@&#123;Number&#125;</span><br><span class="line"><span class="meta">$</span> git stash pop</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [&lt;file&gt;]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复上一个commit的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line"># git archive</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:05 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Git的操作&quot;&gt;&lt;a href=&quot;#Git的操作&quot; class=&quot;headerlink&quot; title=&quot;Git的操作&quot;&gt;&lt;/a&gt;Git
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git搭建仓库</title>
    <link href="http://yoursite.com/2019/04/15/2018-06-06-git%E6%90%AD%E5%BB%BA%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2019/04/15/2018-06-06-git搭建仓库/</id>
    <published>2019-04-15T03:46:00.234Z</published>
    <updated>2019-04-15T03:49:23.166Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><p><strong>Git</strong> 是一个开源的分布式版本控制软件,用以有效、高速的处理从很小到非常大的项目版本管理。 Git 最初是由Linus Torvalds设计开发的，用于管理Linux内核开发。Git 是根据GNU通用公共许可证版本2的条款分发的自由/免费软件，安装参见：<a href="http://git-scm.com/" target="_blank" rel="noopener">http://git-scm.com/</a></p><p><strong>参考：</strong><br><a href="https://www.cnblogs.com/syp172654682/p/7689328.html" target="_blank" rel="noopener">深入浅出Git教程</a><br><br><a href="https://www.yiibai.com/git/git_reset.html" target="_blank" rel="noopener">Git命令教程</a><br><br><a href="https://github.com/geeeeeeeeek/git-recipes/wiki" target="_blank" rel="noopener">高质量的 Git 中文教程，来自国外社区的优秀文章和个人实践</a><br><br><a href="http://gitref.justjavac.com/" target="_blank" rel="noopener">Git参考手册</a></p><h2 id="windows系统配置git"><a href="#windows系统配置git" class="headerlink" title="windows系统配置git"></a>windows系统配置git</h2><p>前面安装过程不在阐述，直说下面如何配置git</p><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;xxx&quot;</span><br><span class="line">$ git config --global user.email &quot;xxx@xxx&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen  #按几次enter回车键，出现目录链接，然后找到xx.pub文件，打开文件，复制里面的内容到github中</span><br></pre></td></tr></table></figure><h2 id="操作git"><a href="#操作git" class="headerlink" title="操作git"></a>操作git</h2><blockquote><p><strong>获得git仓库</strong></p></blockquote><ol><li>通过命令 git init 把这个目录变成git可以管理的仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br></pre></td></tr></table></figure></li></ol><p>这时候你当前目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。</p><ol start="2"><li>克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地，而不是取某一个特定版本，所以用clone而不是checkout<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong>把文件添加到版本库中</strong></p></blockquote><p>git版本控制系统可以告诉你每次的改动，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p>我在版本库目录中新建文本文件，如readme.txt<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一步:使用命令 git add添加到暂存区里面去</span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">第二步：用命令 git commit告诉Git，把文件提交到仓库。</span><br><span class="line">$ git commit -m &quot;readme.txt提交&quot;</span><br></pre></td></tr></table></figure><p></p><blockquote><p><strong>查看文件的状态</strong></p></blockquote><p>实际使用中你不止只有一个文件，或新增或修改多个文件，可能时间一久就忘了有多少文件需要提交，可以使用 git status 命令来查看当前状态,是否有未提交的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><blockquote><p><strong>比较当前文件跟版本文件内容</strong></p></blockquote><p>git diff用于显示WorkSpace中的文件和暂存区文件的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt</span><br><span class="line"></span><br><span class="line"># 查看已缓存的改动</span><br><span class="line">$ git diff --cached</span><br><span class="line"></span><br><span class="line"># 查看已缓存的与未缓存的所有改动</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line">#显示摘要而非整个 diff</span><br><span class="line">$ git diff --stat</span><br></pre></td></tr></table></figure><blockquote><p><strong>查看历史提交记录</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 历史纪录是根据时间倒叙排列的</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 一个压缩后的每一条提交记录只占一行的输出</span><br><span class="line">$ git log --pretty=oneline</span><br><span class="line"></span><br><span class="line"># 只看某一个人的提交记录   </span><br><span class="line">$ git log --author=bob</span><br><span class="line"></span><br><span class="line"># ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签</span><br><span class="line">$ git log --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure><h2 id="文件4种状态"><a href="#文件4种状态" class="headerlink" title="文件4种状态"></a>文件4种状态</h2><ul><li><p>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p></li><li><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p></li><li><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</p></li><li><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified<br><img src="https://images2017.cnblogs.com/blog/63651/201709/63651-20170909091456335-1787774607.jpg" alt="文件4种状态"></p></li></ul><h2 id="理解工作区、暂存区和版本库的区别"><a href="#理解工作区、暂存区和版本库的区别" class="headerlink" title="理解工作区、暂存区和版本库的区别"></a><strong>理解工作区、暂存区和版本库的区别</strong></h2><p><strong>工作区域</strong>：<br>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/BEEA0855273E4CD6AEEBB58822EAF24A?method=download&amp;shareKey=453a30b0974277aea875341bc6cc1b35" alt="image"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li><li></li><li>工作区：就是你在电脑里能看到的目录。<br>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。<br>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br><img src="https://note.youdao.com/yws/api/personal/file/389823FEA5614CB8B6EE9CC40A01FEF9?method=download&amp;shareKey=b10514b7f23959b90d539b59435f06de" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/BBAAA9B4225E479BA04C89C1E6083C79?method=download&amp;shareKey=46ab5f4eb7cdb8f44199246b3180295b" alt="image"></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Git介绍&quot;&gt;&lt;a href=&quot;#Git介绍&quot; class=&quot;headerlink&quot; title=&quot;Git介绍&quot;&gt;&lt;/a&gt;Git介绍&lt;
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/04/02/hello-world/"/>
    <id>http://yoursite.com/2019/04/02/hello-world/</id>
    <published>2019-04-02T04:21:02.820Z</published>
    <updated>2019-04-02T04:21:02.820Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hex
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS 各种Hack手段</title>
    <link href="http://yoursite.com/2017/06/25/css-hack/"/>
    <id>http://yoursite.com/2017/06/25/css-hack/</id>
    <published>2017-06-24T19:25:24.000Z</published>
    <updated>2018-10-20T07:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><a id="more"></a><p>随着浏览器的发展，css hack 技术的使用应该越来越少了，但是在某些关键时刻以及综合的WEB应用或者老项目中，可能还需要使用 css hack 技术来解决一些问题。</p><h1 id="css-hack-分类"><a href="#css-hack-分类" class="headerlink" title="css hack 分类"></a>css hack 分类</h1><p>css hack 分类大致有 3 种表现形式：<strong>IE条件注释法</strong>、<strong>CSS属性前缀法</strong>以及<strong>选择器前缀法</strong>。</p><p>IE 条件注释法（即 HTML 条件注释 Hack）：<br>针对所有IE(注：IE10+ 已经不再支持条件注释)：<br><code>&lt;!--[if IE]&gt;IE浏览器显示的内容 &lt;![endif]--&gt;</code>；</p><p>针对 IE6 及以下版本：<br><code>&lt;!--[if lt IE 6]&gt;只在IE6-显示的内容 &lt;![endif]--&gt;</code>。<br>这类 Hack 不仅对 CSS 生效，对写在判断语句里面的所有代码都会生效。</p><p>属性前缀法（即类内部 Hack）：例如 IE6 能识别下划线 <code>_</code> 和星号 <code>*</code>，IE7 能识别星号 <code>*</code>，但不能识别下划线 <code>_</code>，IE6~IE10 都认识 <code>\9</code>，但 firefox 前述三个都不能认识。</p><p>选择器前缀法（即选择器 Hack）：例如 IE6 能识别 <code>*html .class{}</code>，IE7 能识别 <code>*+html .class{}</code> 或者 <code>*:first-child+html .class{}</code>。</p><p>css hack 书写顺序，一般是将适用范围广、被识别能力强的 CSS 定义在前面。</p><h1 id="条件注释法"><a href="#条件注释法" class="headerlink" title="条件注释法"></a>条件注释法</h1><p><strong>语法：</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if &lt;keywords&gt;? IE &lt;version&gt; ?]&gt;</span></span><br><span class="line"><span class="comment">HTML 代码块</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>取值：</strong><br><code>&lt;keywords&gt;</code><br>if 条件共包含 6 种选择方式：是否、大于、大于或等于、小于、小于或等于、非指定版本<br><strong>是否</strong>：指定是否 IE 或 IE 某个版本。关键字：空<br><strong>大于</strong>：选择大鱼指定版本的 IE 版本。关键字：gt<br><strong>大于或等于</strong>：选择大于或等于指定版本的 IE 版本。关键字：gte<br><strong>小于</strong>：选择小于指定版本的IE版本。关键字：lt<br><strong>小于或等于</strong>：选择小于或等于指定版本的IE版本。关键字：lte<br><strong>非指定版本</strong>：选择除指定版本外的所有IE版本。关键字：!</p><p><strong>说明：</strong><br>用于选择 IE 浏览器及IE的不同版本</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">只在IE下生效</span><br><span class="line">&lt;!--[if IE]&gt;</span><br><span class="line">这段文字只在IE浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">只在IE6下生效</span><br><span class="line">&lt;!--[if IE 6]&gt;</span><br><span class="line">这段文字只在IE6浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">只在IE6以上版本生效</span><br><span class="line">&lt;!--[if gte IE 6]&gt;</span><br><span class="line">这段文字只在IE6以上(包括)版本IE浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">只在IE8上不生效</span><br><span class="line">&lt;!--[if ! IE 8]&gt;</span><br><span class="line">这段文字在非IE8浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">非IE浏览器生效</span><br><span class="line">&lt;!--[if !IE]&gt;</span><br><span class="line">这段文字只在非IE浏览器显示</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><p>需要说明的是，IE10和11已经不支持这种条件注释法了。<a href="/yu/css-hack.html" target="_blank">运行上面示例</a></p><h1 id="CSS-属性前缀法"><a href="#CSS-属性前缀法" class="headerlink" title="CSS 属性前缀法"></a>CSS 属性前缀法</h1><p><strong>语法：</strong><br>selector {<hack>?property:value<hack>?;}</hack></hack></p><p><strong>取值：</strong><br><code>_</code>：选择 IE6 及以下。连接线（中划线）（-）亦可使用，为了避免与某些带中划线的属性混淆，所以使用下划线（_）更为合适。<br><code>*</code>：选择 IE7 及以下。诸如：（+）与（#）之类的均可使用，不过业界对（*）的认知度更高。<br><code>\9</code>：选择 IE6+。<br><code>\0</code>：选择 IE8+ 和 Opera。<br><code>[;property:value;];</code>：选择 webkit 核心浏览器（Chrome,Safari）。IE7 及以下也能识别。中括号内外的 3 个分号必须保留，第一个分号前可以是任意规则或任意多个规则。<br><code>[;color:#f00;];</code> 与 <code>[color:#f00;color:#f00;];</code> 与 <code>[margin:0;padding:0;color:#f00;];</code> 是等价的。生效的始终是中括号内的最后一条规则，所以通常选用第一种写法最为简洁。</p><p><strong>说明：</strong><br><strong>选择不同的浏览器及版本</strong>尽可能减少对 CSS Hack 的使用。Hack 有风险，谨慎使用。<br>一些 CSS Hack 由于浏览器存在交叉认识，所以需要通过层层覆盖的方式来实现对不同浏览器进行 Hack 的。如下面这个例子：<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#090</span>\<span class="number">9</span>; <span class="comment">/* For IE8+ */</span></span><br><span class="line">  *color:#f00;  /* For IE7 and earlier */</span><br><span class="line">  _<span class="selector-tag">color</span>:<span class="selector-id">#ff0</span>;  <span class="comment">/* For IE6 and earlier */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p id="div-border-left-yellow">上述 Hack 均需运行在标准模式下，若在怪异模式下运行，这些 Hack 将会被不同版本的 IE 相互识别，导致失效。</p><h1 id="选择器前缀法"><a href="#选择器前缀法" class="headerlink" title="选择器前缀法"></a>选择器前缀法</h1><p><strong>语法：</strong><br><code>&lt;hack&gt;selector{sRules}</code></p><p><strong>说明：</strong><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="selector-tag">html</span> <span class="selector-class">.test</span>&#123;<span class="attribute">color</span>:<span class="number">#090</span>;&#125;       <span class="comment">/* For IE6 and earlier */</span></span><br><span class="line">* + <span class="selector-tag">html</span> <span class="selector-class">.test</span>&#123;<span class="attribute">color</span>:<span class="number">#ff0</span>;&#125;     <span class="comment">/* For IE7 */</span></span><br><span class="line"><span class="selector-class">.test</span><span class="selector-pseudo">:lang(zh-cn)</span>&#123;<span class="attribute">color</span>:<span class="number">#f00</span>;&#125;  <span class="comment">/* For IE8+ and not IE */</span></span><br><span class="line"><span class="selector-class">.test</span><span class="selector-pseudo">:nth-child(1)</span>&#123;<span class="attribute">color</span>:<span class="number">#0ff</span>;&#125; <span class="comment">/* For IE9+ and not IE */</span></span><br></pre></td></tr></table></figure><p></p><p id="div-border-left-yellow">上述代码中的3,4两行就是典型的利用能力来进行选择的 CSS Hack。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>gulp 详解与使用</title>
    <link href="http://yoursite.com/2017/05/01/gulp/"/>
    <id>http://yoursite.com/2017/05/01/gulp/</id>
    <published>2017-04-30T17:25:24.000Z</published>
    <updated>2018-10-20T07:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><h1 id="什么是-gulp"><a href="#什么是-gulp" class="headerlink" title="什么是 gulp"></a>什么是 gulp</h1><p><a href="http://gulpjs.com/" target="_blank" rel="noopener">gulp</a> 是一个前端构建工具，它能通过自动执行常见任务，比如编译预处理 CSS ，压缩 JavaScript 和刷新浏览器，来改进网站开发的过程，从而使开发更加快速高效。</p><h1 id="为什么要用-gulp"><a href="#为什么要用-gulp" class="headerlink" title="为什么要用 gulp"></a>为什么要用 gulp</h1><p>与 grunt 相比，gulp 无需写一大堆繁杂的配置参数，<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">API</a>（<a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">中文 API</a>） 也非常简单，学习起来很容易，而且 gulp 使用的是 nodejs 中 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">stream</a> 来读取和操作数据，其速度更快。<br>gulp 有庞大的生态圈，且每天都在发展。依靠成千上万可供选择的插件，你可以利用 gulp 自动完成几乎任何事。</p><h1 id="如何使用-gulp"><a href="#如何使用-gulp" class="headerlink" title="如何使用 gulp"></a>如何使用 gulp</h1><h2 id="Installing-Gulp"><a href="#Installing-Gulp" class="headerlink" title="Installing Gulp"></a>Installing Gulp</h2><p>新版的 gulp 命令行工具已经改名为 gulp-cli 。<br>如果你之前安装了全局的 gulp 。在使用新的 gulp-cli 之前，执行命令<br><code>npm rm --global gulp</code> ，将之前的全局 gulp 卸掉。</p><a id="more"></a><h3 id="Install-the-gulp-command"><a href="#Install-the-gulp-command" class="headerlink" title="Install the gulp command"></a>Install the gulp command</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli</span><br></pre></td></tr></table></figure><h3 id="Install-gulp-in-your-devDependencies"><a href="#Install-gulp-in-your-devDependencies" class="headerlink" title="Install gulp in your devDependencies"></a>Install gulp in your devDependencies</h3><p>Run this command in your project directory<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br></pre></td></tr></table></figure><p></p><h2 id="Create-a-gulpfile"><a href="#Create-a-gulpfile" class="headerlink" title="Create a gulpfile"></a>Create a gulpfile</h2><p>Create a file called gulpfile.js in your project root with these contents:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// place code for your default tash here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h2 id="Test-it-out"><a href="#Test-it-out" class="headerlink" title="Test it out"></a>Test it out</h2><p>Run the gulp command in your projct directory:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure><p></p><h1 id="gulp-API"><a href="#gulp-API" class="headerlink" title="gulp API"></a>gulp API</h1><p>gulp 的核心 API 有四个：gulp.task() 、 gulp.src() 、 gulp.dest() 、 gulp.watch() 。<br><a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">gulp API</a><br><a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">gulp API 中文</a></p><p>下面详细介绍一下：</p><h2 id="gulp-src"><a href="#gulp-src" class="headerlink" title="gulp.src()"></a>gulp.src()</h2><p>gulp.src() 可以读取你需要操作的文件，相比于 Grunt 主要以文件为媒介来运行它的工作流，gulp 使用的是 Nodejs 中的 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">stream</a> 流，首先获取到需要的 stream ，然后可以通过 stream 的 pipe() 方法把流导入到你想要的地方，比如 gulp 的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以 gulp 是以 stream 为媒介的，它不需要频繁的生成临时文件，这也是 gulp 的速度比 Grunt 快的一个原因。再回到正题上来，gulp.src() 方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流（Vinyl files），这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，这个我们暂时不用去深入理解，你只需简单的理解可以用这个方法来读取你需要操作的文件就行了。其语法为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(globs [, options])</span><br></pre></td></tr></table></figure><p></p><p>gulp 用到的 glob 的匹配规则以及一些文件匹配技巧。<br>gulp 内部使用了 node-glob 模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：</p><ul><li><code>*</code> 匹配文件路径中的 0 个或多个字符，但不会匹配路径分配符，除非路径分隔符出现在末尾</li><li>** 匹配路径中的 0 个或多个目录及其子目录，需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。</li><li>? 匹配文件路径中的一个字符（不会匹配路径分隔符）</li><li>[…] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为 ^ 或 ! 时，则表示不匹配方括号中出现的其他字符中的任意一个，类似 js 正则表达式中的用法。</li><li>!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的</li><li>?(pattern|pattern|pattern) 匹配括号中给定的任一模式 0 次或 1 次，类似于 js 正则中的(pattern|pattern|pattern)?</li><li>+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少 1 次，类似于正则中的(pattern|pattern|pattern)+</li><li><code>*(pattern|pattern|pattern)</code> 匹配括号中的给定的任一模式 0 次或多次，类似于 js 正则中的 <code>(pattern|pattern|pattern)*</code></li><li>@(pattern|pattern|pattern) 匹配括号中给定的任一模式 1 次，类似于 js 正则中的(pattern|pattern|pattern)</li></ul><p>下面以一系列例子来加深理解</p><ul><li><code>*</code> 能匹配 a.js 、 x.y 、 abc 、 abc/ ，但不能匹配 a/b.js</li><li><code>*.*</code> 能匹配 a.js 、 style.css 、 a.b 、 x.y</li><li><code>*/*/*.js</code> 能匹配 a/b/c.js 、 x/y/z.js ，不能匹配 a/b.js 、a/b/c/d.js</li><li>** 能匹配 abc 、 a/b.js 、 a/b/c.js 、 x/y/z 、x/y/z/a.b ，能用来匹配所有的目录和文件</li><li>*<em>/</em>.js 能匹配 foo.js 、 a/foo.js 、 a/b/foo.js 、 a/b/c/foo.js</li><li>a/**/z 能匹配 a/z 、 a/b/z 、 a/b/c/z 、 a/d/g/h/r/z</li><li><code>a/**b/z</code> 能匹配 a/b/z 、 a/fb/z ，但不能匹配 a/x/gb/z ，因为只有单 ** 单独出现才能匹配多级目录</li><li>?.js 能匹配 a.js 、 b.js 、 c.js</li><li>a?? 能匹配 a.b 、 abc ，但不能匹配 ab/ ，因为它不会匹配路径分隔符</li><li>[xyz].js 只能匹配 x.js 、 y.js 、 z.js ，不会匹配 xy.js 、 xyz.js 等，整个中括号只代表一个字符</li><li>[^xyz].js 能匹配 a.js 、 b.js 、 c.js 等，不能匹配 x.js 、 y.js 、 z.js</li></ul><p>当有多种匹配模式时可以使用数组<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组的方式来匹配多种文件</span></span><br><span class="line">gulp.src([<span class="string">'js/*.js'</span>,<span class="string">'css/*.css'</span>,<span class="string">'*.html'</span>])</span><br></pre></td></tr></table></figure><p></p><p>使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上 ! 即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gulp.src([*.js,<span class="string">'!b*.js'</span>])  <span class="comment">//匹配所有 js 文件，但排除掉以 b 开头的 js 文件</span></span><br><span class="line">gulp.src([<span class="string">'!b*.js'</span>,*.js])  <span class="comment">//不会排除任何文件，因为排除模式不能出现在数组的第一个元素中</span></span><br></pre></td></tr></table></figure><p></p><p>此外，还可以使用展开模式。展开模式以花括号作为定界符，根据它里面的内容，会展开为多个模式，最后匹配的结果为所有展开的模式想加起来得到的结果。展开的例子如下：</p><ul><li>a{b,c}d 会展开为 abd 、 acd</li><li>a{b,}c 会展开为 abc 、 ac</li><li>a{0..3}d 会展开为 a0d 、 a1d 、 a2d 、 a3d</li><li>a{b,c{d,e}f}g 会展开为 abg 、 acdfg 、 acefg</li><li>a{b,c}d{e,f}g 会展开为 abdeg 、 acdeg 、 abdfg 、 abdeg</li></ul><h2 id="gulp-dest"><a href="#gulp-dest" class="headerlink" title="gulp.dest()"></a>gulp.dest()</h2><p>gulp.dest() 方法是用来写文件的，其语法为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.dest(path[, options])</span><br></pre></td></tr></table></figure><p></p><p><strong>path</strong> 为写入文件的路径<br>我们给 gulp.dest() 传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当作是目录名，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</span><br><span class="line">gulp.src(<span class="string">"script/jquery.js"</span>).pipe(gulp.dest(<span class="string">"dist/foo.js"</span>));</span><br><span class="line"><span class="comment">// 最终生成的文件路径为 dist/foo.js/jquery.js ，而不是 dist/foo.js</span></span><br></pre></td></tr></table></figure><p></p><p>要想改变文件名，可以使用插件 gulp-rename<br>下面说说生成的文件路径与我们给 gulp.dest() 方法传入的路径参数之间的关系。<br>gulp.dest(path) 生成的文件路径是我们传入的 path 参数后面再加上 gulp.src() 中有通配符开始出现的那部分路径。例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</span><br><span class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/*.js</span></span><br><span class="line">gulp.src(<span class="string">"script/**/*.js"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//最后生成的文件路径为 dist/**/*.js</span></span><br><span class="line"><span class="comment">//如果 **/*.js 匹配到的文件为 jquery/jquery.js ，则生成的文件路径为 dist/jquery/jquery.js</span></span><br></pre></td></tr></table></figure><p></p><p>再举更多一点的例子<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"script/avalon/avalon.js"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//没有通配符出现的情况，最后生成的文件路径为 dist/avalon.js</span></span><br><span class="line"></span><br><span class="line">gulp.src(<span class="string">"script/**/underscore.js"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/underscore.js</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/util/underscore.js</span></span><br><span class="line"><span class="comment">//则最后生成的文件路径为dist/util/underscore.js</span></span><br><span class="line"></span><br><span class="line">gulp.src(<span class="string">"script/*"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//有通配符出现的那部分路径为*</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/zepto.js</span></span><br><span class="line"><span class="comment">//则最后生成的文件路径为dist/zepto.js</span></span><br></pre></td></tr></table></figure><p></p><p>通过指定 gulp.src() 方法配置参数中的 base 属性，我们可以灵活的来改变 gulp.dest() 生成的文件路径。<br>当我们没有在 gulp.src() 方法配置参数中的 base 属性，base 的默认值为通配符开始出现之前那部分路径，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"app/src/**/*.css"</span>) <span class="comment">//此时base的值为 app/src</span></span><br></pre></td></tr></table></figure><p></p><p>上面我们说的 gulp.dest() 所生成的文件路径的规则，其实也可以理解成，用我们给 gulp.dest() 传入的路径替换掉 gulp.src() 中的 base 路径，最终得到生成文件的路径。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"app/src/**/*.css"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//此时base的值为app/src，也就是说它的base路径为app/src</span></span><br><span class="line"><span class="comment">//设该模式匹配到了文件app/src/css/normal.css</span></span><br><span class="line"><span class="comment">//用dist替换掉base路径，最终得到dist/css/normal.css</span></span><br></pre></td></tr></table></figure><p></p><p>所以改变 base 路径后，gulp.dest() 生成的文件路径也会改变<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"script/lib/*.js"</span>).pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line"><span class="comment">//没有配置base参数，此时默认的base路径为script/lib</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/lib/jquery.js</span></span><br><span class="line"><span class="comment">//生成的文件路径为build/jquery.js</span></span><br><span class="line"></span><br><span class="line">gulp.src(<span class="string">"script/lib/*.js"</span>, &#123;<span class="attr">base</span>: <span class="string">"script"</span>&#125;).pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line"><span class="comment">//配置了base参数，此时base路径为script</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/lib/jquery.js</span></span><br><span class="line"><span class="comment">//此时生成的文件路径为build/lib/jquery.js</span></span><br></pre></td></tr></table></figure><p></p><p>用 gulp.dest() 把文件流写入文件后，文件流仍然可以继续使用。</p><h2 id="gulp-task"><a href="#gulp-task" class="headerlink" title="gulp.task()"></a>gulp.task()</h2><p>gulp.task 方法用来定义任务，内部使用的是 Orchestrator ，其语法为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(name[, deps], fn)</span><br></pre></td></tr></table></figure><p></p><p><strong>name</strong> 为任务名，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。<br><strong>deps</strong> 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数。<br><strong>fn</strong> 为任务函数，我们把任务要执行的代码都要写在里面。该参数也是可选的。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"mytask"</span>, [<span class="string">"array"</span>, <span class="string">"of"</span>, <span class="string">"task"</span>, <span class="string">"names"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个有依赖的任务</span></span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>关于 gulp.task() ，我们需要知道执行多个任务时怎么来控制任务执行的顺序。<br>gulp 中执行多个任务，可以通过任务依赖来实现。例如我想要执行 one ，two ，three 这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要执行default任务，就相当于把one,two,three这三个任务执行了</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>,[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>]);</span><br></pre></td></tr></table></figure><p></p><p>如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。<br>但是如果某个任务所依赖的任务是异步的，就要注意了，gulp 并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// one是一个异步执行的任务</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"one is done"</span>);</span><br><span class="line">  &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//two任务虽然依赖于one任务，但并不会等到one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><img src="/images/gulp-1.png" alt><br>上面的例子中我们执行 two 任务时，会先执行 one 任务，但不会去等待 one 任务中的异步操作完成后再执行 two 任务，而是紧接着执行 two 任务。因为 one 任务耗时 3 秒，所以 two 任务会在 one 任务中的异步操作完成之前就执行了。</p><p>那如果我们想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？<br>有三种方法可以实现：</p><p>第一：在异步操作完成后执行一个回调函数来通知 gulp 这个异步任务已经完成，这个回调函数就是任务函数的第一个参数。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"one"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//cb为任务函数提供的回调，用来通知任务已经完成</span></span><br><span class="line">  <span class="comment">//one是一个异步执行的任务</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"one is done"</span>);</span><br><span class="line">    cb(); <span class="comment">//执行回调，表示这个异步任务已经完成</span></span><br><span class="line">  &#125;,<span class="number">5000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时two任务会在one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>第二：定义任务时返回一个流对象。适用于任务就是操作 gulp.src 获取到的流的情况。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"one"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stream = gulp.src(<span class="string">"client/**/*.js"</span>)</span><br><span class="line">      .pipe(dosomething()) <span class="comment">//dosomething()中有某些异步操作</span></span><br><span class="line">      .pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是two任务会在one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>第三：返回一个 promise 对象，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>); <span class="comment">//一个著名的异步处理的库 https://github.com/kriskowal/q</span></span><br><span class="line">gulp.task(<span class="string">"one"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line">  <span class="comment">//做一些异步操作</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    deferred.resolve();</span><br><span class="line">  &#125;,<span class="number">5000</span>);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>关于 gulp.task() ，主要的就是要清除当依赖异步任务时要如何处理。</p><h2 id="gulp-watch"><a href="#gulp-watch" class="headerlink" title="gulp.watch()"></a>gulp.watch()</h2><p>gulp.watch() 用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(glob[, opts], tasks);</span><br></pre></td></tr></table></figure><p></p><p><strong>glob</strong> 为要监视的文件匹配模式，规则和用法与 gulp.src() 方法中的 glob 相同。<br><strong>opts</strong> 为一个可选的配置对象，通常不需要用到。<br><strong>tasks</strong> 为文件变化后要执行的任务，为一个数组<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"uglify"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">"reload"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br><span class="line">gulp.watch(<span class="string">"js/**/*.js"</span>, [<span class="string">"uglify"</span>,<span class="string">"reload"</span>]);</span><br></pre></td></tr></table></figure><p></p><p>gulp.watch(glob [,opts, cb])<br><strong>glob</strong> 和 <strong>opts</strong> 参数与第一种用法相同<br><strong>cb</strong> 参数为一个函数。每当监视的文件发生变化时，就会调用这个函数，并且会给它传入一个对象，该对象包含了文件变化的一些信息，type 属性为变化的类型，可以是 added 、changed 、deleted ，path 属性为发生变化的文件的路径<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(<span class="string">"js/**/*.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type); <span class="comment">//变化类型added为新增，deleted为删除，changed为改变</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.path); <span class="comment">//变化的文件的路径</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h1 id="gulp-的插件"><a href="#gulp-的插件" class="headerlink" title="gulp 的插件"></a>gulp 的插件</h1><p>gulp 本身虽然不能完成很多任务，但它有大量插件可用，我们可以在 <a href="http://gulpjs.com/plugins/" target="_blank" rel="noopener">插件页面</a> 或者在 npm 搜索 gulpplugin 。<br>列一些很棒的 plugin ：</p><ul><li><a href="https://www.npmjs.com/package/gulp-jshint/" target="_blank" rel="noopener">JSHint</a> ： js代码检查分析工具</li><li><a href="https://www.npmjs.com/package/gulp-coffee/" target="_blank" rel="noopener">gulp-coffee</a> ： 编译CoffeeScript</li><li><a href="https://www.npmjs.com/package/gulp-mocha" target="_blank" rel="noopener">gulp-mocha</a> ： 执行Mocha测试</li><li><a href="https://www.npmjs.com/package/gulp-bump" target="_blank" rel="noopener">gulp-bump</a> ： 更新版本号</li><li><a href="https://www.npmjs.com/package/gulp-sass" target="_blank" rel="noopener">gulp-sass</a> ： sass 编译</li><li><a href="http://www.browsersync.cn/docs/gulp/" target="_blank" rel="noopener">browser-sync</a> ： 浏览器自动刷新</li><li><a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a> ： 代码压缩</li><li><a href="https://www.npmjs.com/package/gulp-concat" target="_blank" rel="noopener">gulp-concat</a> ： 合并</li><li><a href="https://www.npmjs.com/package/gulp-eslint" target="_blank" rel="noopener">gulp-eslint</a> ： 支持 ES6 JSX</li></ul><h1 id="gulp-命令行参数"><a href="#gulp-命令行参数" class="headerlink" title="gulp 命令行参数"></a>gulp 命令行参数</h1><ul><li><code>-v</code> 或 <code>--version</code> 会显示全局和项目本地所安装的 gulp 版本号</li><li><code>--require &lt;module path&gt;</code> 将会在执行之前 require 一个模块。这对于一些语言编译器或者需要其他应用的情况来说很有用。你可以使用多个 <code>--require</code></li><li><code>--gulpfile &lt;gulpfile path&gt;</code> 手动指定一个 gulpfile 的路径，这在你有很多个 gulpfile 的时候很有用。这也会将 CWD 设置到该 gulpfile 所在目录</li><li><code>--cwd &lt;dir path&gt;</code> 手动指定 CWD 。定义 gulpfile 查找的位置，此外，所有的相应的依赖（require）会从这里开始计算相对路径</li><li><code>-T</code> 或 <code>--tasks</code> 会显示所指定 gulpfile 的 task 依赖树</li><li><code>--tasks-simple</code> 会以纯文本的方式显示所载入的 gulpfile 中的 task 列表</li><li><code>--color</code> 强制 gulp 和 gulp 插件显示颜色，即便没有颜色支持</li><li><code>--no-color</code> 强制不显示颜色，即便检测到有颜色支持</li><li><code>--silent</code> 禁止所有的 gulp 日志</li></ul><p>命令行会在 process.env.INIT_CW 中记录它是从哪里被运行的。</p><h1 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h1><p>1、gulp 写进项目 package.json 文件的依赖有什么作用<br>方便别人查看你项目中有些什么依赖，而且在项目目录下执行 npm install 命令会安装项目 package.json 中的所有依赖模块，这样就能简化项目的安装程序了，不用一个一个模块去安装啊。</p><p>2、gulp 中着重了解 gulp.task() 如何处理依赖任务是耗时操作或者异步操作的情况。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;什么是-gulp&quot;&gt;&lt;a href=&quot;#什么是-gulp&quot; class=&quot;headerlink&quot; title=&quot;什么是 gulp&quot;&gt;&lt;/a&gt;什么是 gulp&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://gulpjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gulp&lt;/a&gt; 是一个前端构建工具，它能通过自动执行常见任务，比如编译预处理 CSS ，压缩 JavaScript 和刷新浏览器，来改进网站开发的过程，从而使开发更加快速高效。&lt;/p&gt;&lt;h1 id=&quot;为什么要用-gulp&quot;&gt;&lt;a href=&quot;#为什么要用-gulp&quot; class=&quot;headerlink&quot; title=&quot;为什么要用 gulp&quot;&gt;&lt;/a&gt;为什么要用 gulp&lt;/h1&gt;&lt;p&gt;与 grunt 相比，gulp 无需写一大堆繁杂的配置参数，&lt;a href=&quot;https://github.com/gulpjs/gulp/blob/master/docs/API.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;API&lt;/a&gt;（&lt;a href=&quot;http://www.gulpjs.com.cn/docs/api/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文 API&lt;/a&gt;） 也非常简单，学习起来很容易，而且 gulp 使用的是 nodejs 中 &lt;a href=&quot;https://nodejs.org/api/stream.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stream&lt;/a&gt; 来读取和操作数据，其速度更快。&lt;br&gt;gulp 有庞大的生态圈，且每天都在发展。依靠成千上万可供选择的插件，你可以利用 gulp 自动完成几乎任何事。&lt;/p&gt;&lt;h1 id=&quot;如何使用-gulp&quot;&gt;&lt;a href=&quot;#如何使用-gulp&quot; class=&quot;headerlink&quot; title=&quot;如何使用 gulp&quot;&gt;&lt;/a&gt;如何使用 gulp&lt;/h1&gt;&lt;h2 id=&quot;Installing-Gulp&quot;&gt;&lt;a href=&quot;#Installing-Gulp&quot; class=&quot;headerlink&quot; title=&quot;Installing Gulp&quot;&gt;&lt;/a&gt;Installing Gulp&lt;/h2&gt;&lt;p&gt;新版的 gulp 命令行工具已经改名为 gulp-cli 。&lt;br&gt;如果你之前安装了全局的 gulp 。在使用新的 gulp-cli 之前，执行命令&lt;br&gt;&lt;code&gt;npm rm --global gulp&lt;/code&gt; ，将之前的全局 gulp 卸掉。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="gulp" scheme="http://yoursite.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>AMD，CMD 规范详解</title>
    <link href="http://yoursite.com/2017/03/20/amd-cmd/"/>
    <id>http://yoursite.com/2017/03/20/amd-cmd/</id>
    <published>2017-03-19T19:25:24.000Z</published>
    <updated>2018-10-20T07:46:51.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><p>当我们了解了 <a href="https://neveryu.github.io/2017/03/07/commonjs/" target="_blank" rel="noopener">CommonJS</a> 以后，<code>CommonJS</code> 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<br>由于 <code>Node.js</code> 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 <code>CommonJS</code> 规范比较适用。<br>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>第二行 <code>math.add(2, 3)</code>，在第一行 <code>require(&#39;math&#39;)</code> 之后运行，因此必须等 <code>math.js</code> 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>对于浏览器，这是一个大问题，因为模块都放在服务器端。等待时间取决于网速的快慢，可能要等很长时间，浏览器处理“假死”状态。</p><p>因此，浏览器端的模块，不能采用“同步加载”，只能采用“异步加载”。</p><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p><a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a> 则是异步加载模块，允许指定回调函数。因此浏览器端一般采用 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>。<br><code>AMD(Asynchronous module definition)</code>： <span id="inline-green">异步模块定义。</span></p><p>类似的还有 <code>CommonJS Modules/2.0</code> 规范，是 <code>BravoJS</code> 在推广过程中对模块定义的规范化产出。<br><code>CMD(Common module definition)</code>：<span id="inline-blue">通用模块定义。</span></p><p>目前这些规范的实现都能达成<strong>浏览器端模块化开发的目的</strong>。</p><table><thead><tr><th style="text-align:center">服务端JS</th><th style="text-align:center">浏览器端JS</th></tr></thead><tbody><tr><td style="text-align:center">相同的代码需要多次执行</td><td style="text-align:center">代码需要从一个服务器端分发到多个客户端执行</td></tr><tr><td style="text-align:center">CPU 和内存资源是瓶颈</td><td style="text-align:center">宽带是瓶颈</td></tr><tr><td style="text-align:center">加载时从磁盘中加载</td><td style="text-align:center">加载时需要通过网络加载</td></tr></tbody></table><p>AMD 的诞生，就是为了解决这两个问题：<br>1.实现 js 文件的异步加载，避免网页失去响应<br>2.管理模块之间的依赖性，便于代码的编写和维护</p><p>AMD(异步模块定义)主要为前端 JS 的表现指定规范。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><p>AMD 也采用 <a href="https://github.com/amdjs/amdjs-api/wiki/require" target="_blank" rel="noopener">require()</a> 语句加载模块，但是不同于 CommonJS，它要求两个参数：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br></pre></td></tr></table></figure><p></p><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数 callback，则是加载成功之后的回调函数：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>实现 AMD 规范的加载器其实是挺多的，目前，主要有两个 Javascript 库实现了 AMD 规范：<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 和 <a href="https://github.com/cujojs/curl" target="_blank" rel="noopener">curl.js</a>。不过多数人还是用 require.js 。<br>另外如果对 ES6 的模块感兴趣，可以考虑 <a href="http://github.com/hax/my.js" target="_blank" rel="noopener">my.js</a> ，是按照 ES6 草案的 module/loader 规范实现的。</p><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a> 是 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 在推广过程中对模块定义的规范化产出。</p><p>推荐学习 <a href="http://requirejs.org/" target="_blank" rel="noopener">require.js</a>。</p><h2 id="AMD-模块的写法"><a href="#AMD-模块的写法" class="headerlink" title="AMD 模块的写法"></a>AMD 模块的写法</h2><p><a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，采用 AMD 规范。也就是说，模块必须按照 AMD 的规定来写。<br>具体来说，就是模块必须采用特定的 define() 函数来定义。如果一个模块不依赖其他模块。那么可以直接定义在 define() 函数之中。<br>假定现在有一个 math.js 文件，它定义了一个 math 模块。那么，math.js 就要这样写：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　<span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> x+y;</span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　add: add</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>加载方法如下：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</span><br><span class="line">　alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>如果这个模块还依赖其他模块，那么 define() 函数的第一个参数，必须是一个数组，指明该模块的依赖性。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myLib</span>)</span>&#123;</span><br><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　myLib.doSomething();</span><br><span class="line">　&#125;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　foo : foo</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>当 require() 函数加载上面这个模块的时候，就会先加载 myLib.js 文件。</p><h2 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h2><p>理论上，<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，必须是按照 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>、用 define() 函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如 jQuery ）符合 AMD 规范，更多的库并不符合。那么，require.js 是否能够加载非规范的模块呢？<br>回答是可以的。<br>这样的模块在用 require() 加载之前，要先用 require.config() 方法，定义它们的一些特征。<br>举例来说，underscore 和 backbone 这两个库，都没有采用 AMD 规范编写。如果要加载它们的话，必须先定义它们的特征。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">　shim: &#123;</span><br><span class="line">　　<span class="string">'underscore'</span>: &#123;</span><br><span class="line">　　　exports: <span class="string">'_'</span></span><br><span class="line">　　&#125;,</span><br><span class="line">　　<span class="string">'backbone'</span>: &#123;</span><br><span class="line">　　　deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</span><br><span class="line">　　　exports: <span class="string">'Backbone'</span></span><br><span class="line">　　&#125;</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>require.config() 接受一个配置对象，这个对象除了有前面说过的 paths 属性之外，还有一个 shim 属性，专门用来配置不兼容的模块。具体来说，每个模块要定义：<br>（1）exports 值（输出的变量名），表明这个模块外部调用时的名称；<br>（2）deps 数组，表明该模块的依赖性。<br>比如，jQuery 的插件可以这样定义：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shim: &#123;</span><br><span class="line">　<span class="string">'jquery.scroll'</span>: &#123;</span><br><span class="line">　　deps: [<span class="string">'jquery'</span>],</span><br><span class="line">　　exports: <span class="string">'jQuery.fn.scroll'</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">CMD</a> 是 <a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">sea.js</a> 在推广过程中对模块定义的规范化产出。</p><h3 id="CMD-模块定义"><a href="#CMD-模块定义" class="headerlink" title="CMD 模块定义"></a>CMD 模块定义</h3><p>在 CMD 规范中，一个模块就是一个文件。define 是一个全局函数，用来定义模块。<br>define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。<br>factory 为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以定义一个 JSON 数据模块：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;<span class="string">"foo"</span>: <span class="string">"bar"</span>&#125;);</span><br></pre></td></tr></table></figure><p></p><p>也可以通过字符串定义模板模块：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'I am a template.My name is &#123;&#123;name&#125;&#125;.'</span>);</span><br></pre></td></tr></table></figure><p></p><p>factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。<br>factory 是一个函数，有三个参数，function(require, exports, module)<br>1、require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id)<br>2、exports 是一个对象，用来向外提供模块接口<br>3、module 是一个对象，上面存储了与当前模块相关联的一些属性和方法<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 依赖就近书写，什么时候用到什么时候引入</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>建议写一写 SeaJS 的 CMD 规范，与 AMD 非常类似，在国内的影响力非常大，但是个人觉得 SeaJS 比 RequireJS 好很多，另外由于是国人开发的，交流也非常方便，可以看到 github 上的更新、互动非常频繁。</p><h1 id="AMD-与-CMD-的区别"><a href="#AMD-与-CMD-的区别" class="headerlink" title="AMD 与 CMD 的区别"></a>AMD 与 CMD 的区别</h1><p>区别：</p><ol><li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li><li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;当我们了解了 &lt;a href=&quot;https://neveryu.github.io/2017/03/07/commonjs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CommonJS&lt;/a&gt; 以后，&lt;code&gt;CommonJS&lt;/code&gt; 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。&lt;br&gt;由于 &lt;code&gt;Node.js&lt;/code&gt; 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 &lt;code&gt;CommonJS&lt;/code&gt; 规范比较适用。&lt;br&gt;但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（一）：浅谈微服务</title>
    <link href="http://yoursite.com/2017/03/07/Spring%20Cloud%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B5%85%E8%B0%88%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2017/03/07/Spring Cloud（一）：浅谈微服务/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-11T03:25:10.770Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><h2 id="什么是微服务架构呢？"><a href="#什么是微服务架构呢？" class="headerlink" title="什么是微服务架构呢？"></a>什么是微服务架构呢？</h2><p>​ 微服务是系统架构上的一种设计风格，它是将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务之间通过基于HTTP的RESTful API进行通信协作。被拆分成的每一个小型服务都是围绕着系统中某一项或者一些耦合度较高业务功能进行构建，并且每个服务都维护自身的数据存储、业务开发、自动化测试以及独立的部署机制。</p><h2 id="Spring-Cloud-简介"><a href="#Spring-Cloud-简介" class="headerlink" title="Spring Cloud 简介"></a>Spring Cloud 简介</h2><p>Spring Cloud 是一个基于Spring Boot 实现的微服务架构开发工具。它为微服务架构中涉及的配置管理、服务治理、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供一种简单的开发方式。</p><h2 id="Spring-Cloud的优势"><a href="#Spring-Cloud的优势" class="headerlink" title="Spring Cloud的优势"></a>Spring Cloud的优势</h2><p>微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring Cloud的呢？</p><ul><li>产出于spring大家族，spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善。</li><li>有Spring Boot 这个独立干将可以省很多事，大大小小的活Spring Boot都搞的挺不错。</li><li>作为一个微服务治理的大家伙，考虑的很全面，几乎服务治理的方方面面都考虑到了，方便开发开箱即用。</li><li>Spring Cloud 活跃度很高，教程很丰富，遇到问题很容易找到解决方案</li><li>轻轻松松几行代码就完成了熔断、均衡负责、服务中心的各种平台功能</li></ul><h2 id="核心成员"><a href="#核心成员" class="headerlink" title="核心成员"></a>核心成员</h2><h3 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h3><p>这可是个大boss，地位仅次于老大，老大各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的小弟主要有Eureka, Hystrix, Zuul, Archaius… 太多了</p><ul><li><strong>Netflix Eureka</strong></li><li><strong>Netflix Hystrix</strong></li><li><strong>Netflix Zuul</strong></li><li><strong>Netflix Archaius</strong></li></ul><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><h3 id="Spring-Cloud-for-Cloud-Foundry"><a href="#Spring-Cloud-for-Cloud-Foundry" class="headerlink" title="Spring Cloud for Cloud Foundry"></a>Spring Cloud for Cloud Foundry</h3><h3 id="Spring-Cloud-Cluster"><a href="#Spring-Cloud-Cluster" class="headerlink" title="Spring Cloud Cluster"></a>Spring Cloud Cluster</h3><h3 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;什么是微服务架构呢？&quot;&gt;&lt;a href=&quot;#什么是微服务架构呢？&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务架
      
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://yoursite.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化</title>
    <link href="http://yoursite.com/2017/03/07/2018-06-30-MySQL%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/03/07/2018-06-30-MySQL优化/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-15T04:10:29.485Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:05 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:05 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（二）：服务治理Eureka</title>
    <link href="http://yoursite.com/2017/03/07/Spring%20Cloud%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86Eureka/"/>
    <id>http://yoursite.com/2017/03/07/Spring Cloud（二）：服务治理Eureka/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-11T03:25:10.747Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><h2 id="什么是Spring-Cloud-Eureka？"><a href="#什么是Spring-Cloud-Eureka？" class="headerlink" title="什么是Spring Cloud Eureka？"></a>什么是Spring Cloud Eureka？</h2><p>Spring Cloud Eureka 是 Spring Cloud Netflix微服务套件中的一部分，是在Eureka开源组件进一步封装。服务中心又称注册中心，管理各种服务功能包括服务的注册、发现、熔断、负载、降级等，比如dubbo admin后台的各种功能。</p><p>Eureka 是一个基于 REST 的服务，主要在 AWS 云中使用, 定位服务来进行中间层服务器的负载均衡和故障转移。</p><p>Eureka的基本架构有三种角色。</p><ul><li><p><strong>Register Service:服务注册中心</strong>，它是一个Eureka Server，提供服务注册和发现的功能</p><ul><li>失效剔除</li></ul><p><u>Eureka Server在启动的时候会创建一个定时任务，默认每隔30秒将当前清单中超时90秒没有续约的服务剔除出去。</u></p><ul><li>自我保护</li></ul><p><u>服务注册到Eureka Server后，会维护一个心跳连接。Eureka Server在运行期间，会统计心跳失败的比例在15分钟内是否低于85%，如果出现低于的情况，Eureka Server 会将当前的实例注册信息保护起来，让这些实例不会过期。</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>Provider Service:服务提供者</strong>，它是一个Eureka Client，提供服务</p><ul><li>服务注册</li></ul><p><u>“服务提供者”启动的时候发送REST请求将自己注册到Eureka Server，同时带上自身的元数据信息。Eureka Server接收到REST请求后，将元数据存储到一个双层结构Map中，第一层的key是服务名，第二层key是具体服务的实例名。</u></p><ul><li>服务同步</li></ul><p><u>由于服务注册中心之间因互相注册为服务，当服务提供者发送注册请求到一个服务注册中心，它会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。</u></p><ul><li>服务续约</li></ul><p><u>注册完服务之后，服务提供者会维护一个心跳用来持续告诉Eureka Server，我还活着，防止Eureka Server 剔除任务将服务实例从服务列表中排除出去</u>。</p></li><li><p><strong>Comsumer Service:服务消费者</strong>，它是一个Eureka Client，消费服务</p><ul><li>获取服务</li></ul><p><u>启动服务消费者，它发送一个REST请求给服务注册中心，获取注册服务清单。Eureka Server会维护一份只读的服务清单返回给客户端，同时清单会每隔30秒更新一次。</u></p><ul><li>服务调用</li></ul><p><u>服务消费者在获取服务清单后，通过服务名可以获取具体服务的实例名和实例的元数据信息。（每个服务客户端需要注册到一个Zone中，每个客户端对应一个Region和一个Zone。在服务调用的时候，优先访问同处一个Zone的服务提供方，如果访问不到，就访问其他Zone）</u></p><ul><li>服务下线</li></ul><p><u>当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，服务端接收到请求后，将该服务状态设置为下线（DOWN），并把下线的事件传播出去。</u></p></li></ul><p>服务流程是先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行</p><h2 id="什么是服务治理？"><a href="#什么是服务治理？" class="headerlink" title="什么是服务治理？"></a>什么是服务治理？</h2><p>服务治理是微服务架构中最为核心和基础的模块，它主要用来实现各个微服务实例的自动化注册与发现。</p><p><img src="https://note.youdao.com/yws/api/personal/file/C8F0E49F8A384402B440C63AC6F5D81D?method=download&amp;shareKey=59c1b82b4243a9f5bd812f8f8b6bca5e" alt="1534400474739"></p><ul><li>服务注册</li></ul><p>在服务治理的框架中，通常会构建一个服务注册中心，每个服务单元向注册中心登记自己提供的服务，将主机与端口好、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务名单。服务注册中心还需要以==心跳的方式==去检测清单中的服务是否可用，若不可用需要从服务清单中剔除掉。</p><ul><li>服务发现</li></ul><p>服务间的调用是通过向服务名发起请求调用实现。调用方向服务注册中心咨询服务，并获得所有服务的实例清单，以实现对具体服务实例的访问。当服务发起调用的时候，就从这份清单用某种轮询策略去除一个位置来进行服务调用。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>搭建服务注册中心</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   <span class="comment">&lt;!--这个springboot2.x以上，springcloud指定的版本--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">  <span class="comment">#代表不向注册中心注册自己</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>   </span><br><span class="line">    <span class="comment">#注册中心是维护服务实例，不需要去检索服务</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span>   </span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="高可用注册中心（集群）"><a href="#高可用注册中心（集群）" class="headerlink" title="高可用注册中心（集群）"></a>高可用注册中心（集群）</h2><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>application.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-ha</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer1</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer2:8762/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">eureka-ha</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>电脑配置：</p><p>因为是在本地搭建Eureka Server 集群，所以需要修改本地的host o Windows 系统的电脑<br>在C: /windows/system32/drivers/etc/hosts 中修改， Mac 系统的电脑通过终端vim/etc/hosts 进行编<br>辑修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 peer1</span><br><span class="line">127.0.0.1 peer2</span><br></pre></td></tr></table></figure><p>启动peer1,peer2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar xx.jar --spring.profiles.active=peer1</span><br><span class="line">java -jar xx.jar --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;什么是Spring-Cloud-Eureka？&quot;&gt;&lt;a href=&quot;#什么是Spring-Cloud-Eureka？&quot; class=&quot;
      
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://yoursite.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（五）：Spring Cloud Zuul</title>
    <link href="http://yoursite.com/2017/03/07/Spring%20Cloud%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ASpring%20Cloud%20Zuul/"/>
    <id>http://yoursite.com/2017/03/07/Spring Cloud（五）：Spring Cloud Zuul/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-11T03:25:10.816Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><h2 id="什么是Spring-Cloud-Zuul？"><a href="#什么是Spring-Cloud-Zuul？" class="headerlink" title="什么是Spring Cloud Zuul？"></a>什么是Spring Cloud Zuul？</h2><p>Zuul作为路由网关组件，将所有服务的API接口统一聚合，并且一起对外暴露。外界不用知道内部的各个服务相互调用的复杂性，从而保护了内部微服务单元的API接口，防止被外界直接调用，导致服务的敏感信息暴露。</p><p><img src="https://note.youdao.com/yws/api/personal/file/A987B794E9974665AE54954733F623B7?method=download&amp;shareKey=a7ab1832575b4659f6b5fb8a98ce65f7" alt></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Zuul是通过Servlet实现的，通过自定义的ZuulServlet（这一点有点像springmvc的dispatchServlet）来对请求进行控制。ZuulServlet 的作用是初始化ZuulFilter，并编排这些ZuulFilter 的执行顺序。Zuul的核心就是一堆的过滤器，可以在Http请求和响应执行一堆过滤器。</p><p><strong>大概流程应该是这样的</strong>：当一个客户端Request 请求进入Zuul 网关服务时，网关先进入“<strong>pre filter</strong>”，进行一系列的验证、操作或者判断。然后给“<strong>routing filter</strong> ”进行路由转发，转发到具体的服务实例进行逻辑处理、返回数据。当具体的服务处理完后，最后由“<strong>post filter</strong> “进行处理， 该类型的处理器处理完之后，将Response 信息返回给客户端。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>通过配置文件我们知道，Spring Cloud Zuul 将自己作为一个服务注册到了Eureka。这也就意味着Zuul可以拿到所有注册到Eureka的其他服务的信息。Zuul为这些服务创建了默认的路由规则：<strong>/{servicename}/**</strong></p><h4 id="POM-配置"><a href="#POM-配置" class="headerlink" title="POM 配置"></a>POM 配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    hiapi:</span>  <span class="comment">#自己定义的</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/hiapi/**</span>    <span class="comment">#就可以将指定类型的请求Uri 路由到指定的Serviceld</span></span><br><span class="line"><span class="attr">      serviceid:</span> <span class="string">eureka-client</span></span><br><span class="line"><span class="attr">    ribbonapi:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/ribbonapi/**</span></span><br><span class="line"><span class="attr">      serviceid:</span> <span class="string">eureka-ribbon-client</span></span><br><span class="line"><span class="attr">    feignapi:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/feignapi/**</span></span><br><span class="line">      <span class="string">serviceid</span> <span class="string">:</span> <span class="string">eureka-feign-client</span></span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;什么是Spring-Cloud-Zuul？&quot;&gt;&lt;a href=&quot;#什么是Spring-Cloud-Zuul？&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://yoursite.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Git命令列表</title>
    <link href="http://yoursite.com/2017/03/07/2018-06-06-git%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2017/03/07/2018-06-06-git冲突解决/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-15T03:49:23.187Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:05 GMT+0800 (GMT+08:00) --><p>现在有master和dev两个分支</p><p>​ master和dev分支都有对同一个文件进行了修改并提交</p><p>​ 当master进行==git merge dev== 合并操作时，会出现冲突</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0" alt="git-br-feature1"></p><p>三支合并</p><blockquote><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p></blockquote><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0" alt="git-br-conflict-merged"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:05 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;现在有master和dev两个分支&lt;/p&gt;&lt;p&gt;​ master和dev分支都有对同一个文件进行了修改并提交&lt;/p&gt;&lt;p&gt;​ 当master进行
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2017/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/03/07/设计模式/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-15T03:45:37.510Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><p>[TOC]</p><h1 id="一、设计模式的六大原则"><a href="#一、设计模式的六大原则" class="headerlink" title="一、设计模式的六大原则"></a>一、设计模式的六大原则</h1><h3 id="总原则：开闭原则（Open-Close-Principle）"><a href="#总原则：开闭原则（Open-Close-Principle）" class="headerlink" title="总原则：开闭原则（Open Close Principle）"></a>总原则：开闭原则（Open Close Principle）</h3><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p><h3 id="2、里氏替换原则（Liskov-Substitution-Principle）"><a href="#2、里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏替换原则（Liskov Substitution Principle）"></a>2、里氏替换原则（Liskov Substitution Principle）</h3><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p><p>历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h3><p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。（<strong>抽象不应该依赖细节，细节应该依赖于抽象</strong>）</p><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h3><p>这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><h3 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h3><p>就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p><p>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h3><p>原则是尽量首先使用合成/聚合的方式，而不是使用继承。</p><p>使用“Has-A”和“Is-A”来判断:</p><p>“Is－A”代表一个类是另外一个类的一种，可以使用继承关系，而“Has-A”代表一个类是另外一个类的一个角色，而不是另外一个类的特殊种类。</p><h1 id="二、设计模式分类"><a href="#二、设计模式分类" class="headerlink" title="二、设计模式分类"></a>二、设计模式分类</h1><p>Java中设计模式（java design patterns）通常有23种。模式可以分成3类：创建型、行为型和结构型。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式涉及对象的实例化，特点是不让用户代码依赖于对象的创建或者排列方式，避免用户直接使用new创建对象。</p><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><h3 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h3><p>单例对象能保证在一个JVM中，该对象只有一个实例存在。好处在于：</p><ul><li><p>某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</p></li><li><p>省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</p></li><li><p>有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p></li></ul><h4 id="饿汉式单例类"><a href="#饿汉式单例类" class="headerlink" title="饿汉式单例类"></a>饿汉式单例类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//饿汉单例模式</span></span><br><span class="line">    <span class="comment">//在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有默认构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂方法</span></span><br><span class="line"><span class="comment">     * 静态，不用同步（类加载时已初始化，不会有多线程的问题）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉式是典型的空间换时间</strong>，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。</p><p>所以饿汉式是<strong>线程安全</strong>的</p><h4 id="懒汉式单例类"><a href="#懒汉式单例类" class="headerlink" title="懒汉式单例类"></a>懒汉式单例类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//懒汉式单例模式</span></span><br><span class="line">    <span class="comment">//比较懒，在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢</span></span><br><span class="line">    <span class="comment">//静态私用成员，没有初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有默认构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂方法</span></span><br><span class="line"><span class="comment">     * 同步保证多线程时的正确性（因为类变量不是在加载时初始化的）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式是典型的时间换空间</strong>,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。</p><p>由于懒汉式的实现是涉及到线程安全的问题，所以一般会使用关键字synchronized来实现线程安全，这样会降低整个访问的速度，而且每次都要判断。</p><h3 id="2、简单工厂方法模式"><a href="#2、简单工厂方法模式" class="headerlink" title="2、简单工厂方法模式"></a>2、简单工厂方法模式</h3><p><img src="https://note.youdao.com/yws/api/personal/file/B629A5676A8A4C939E9981354AF73C0B?method=download&amp;shareKey=13825c1a0b1b0f882b67565e9a999be7" alt></p><p>简单工厂模式实现了<strong>生成产品类的代码跟客户端代码分离</strong>，在工厂类中你可以添加所需的生成产品的逻辑代码，但是问题来了，优秀的java代码是符合“开放-封闭”原则的，也就是说对扩展开发，对修改关闭，如果你要加一个产品类C，你就要修改工厂类里面的生成产品的代码，在这里你就要增加if-else判断。<strong>严重违反了开闭原则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明类所需继承的共同接口，也可以是抽象类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以在工厂类中添加任何你所需要的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">create</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//生成ProductA</span></span><br><span class="line">        <span class="keyword">if</span>(str.equalsIgnoreCase(<span class="string">"ProductA"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//生成ProductB</span></span><br><span class="line">            <span class="keyword">if</span>(str.equalsIgnoreCase(<span class="string">"ProductB"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用Factory的静态方法生成所要的类</span></span><br><span class="line">        Factory.create(<span class="string">"productA"</span>);</span><br><span class="line">        Factory.create(<span class="string">"ProductB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、抽象工厂方法模式"><a href="#3、抽象工厂方法模式" class="headerlink" title="3、抽象工厂方法模式"></a>3、抽象工厂方法模式</h3><p><strong>工厂模式 与 抽象工厂模式的区别：</strong></p><blockquote><p>工厂方法模式：<br>一个抽象产品类，可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类只能创建一个具体产品类的实例。</p><p>抽象工厂模式：(<strong>多个产品线，你想换什么产品配置，直接建一个工厂就行了</strong>)<br>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品</p></blockquote><p><strong>类图：</strong></p><p><img src="https://note.youdao.com/yws/api/personal/file/1390851141E544C3B5136ADDBD5E7EFA?method=download&amp;shareKey=854d389c2d7d3286a9ee2968aed11fdc" alt></p><p><strong>抽象工厂有个弊端：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的工厂里加代码，又要在具体的里面加代码。</p><p>可以使用反射+配置文件来解决抽象工厂方法中更换数据库替换的方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getDb</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        String db = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream in = DataAccess.class.getClassLoader().getResourceAsStream(<span class="string">"sql.properties"</span>);</span><br><span class="line">            prop.load(in);</span><br><span class="line">            db = prop.getProperty(<span class="string">"db"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> db;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//反射到对应的Class</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getSqlFactory(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String className = <span class="string">"com.hhy.algorithm.designPattern.AbstractFactory."</span>+getDb()+name;</span><br><span class="line">        System.out.println(className);</span><br><span class="line">        Class&lt;?&gt; c1 = Class.forName(className);</span><br><span class="line">        System.out.println(c1.getName());</span><br><span class="line">        <span class="keyword">return</span> c1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUser <span class="title">CreateUser</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c1 = getSqlFactory(<span class="string">"User"</span>);</span><br><span class="line">        <span class="comment">//获取实例</span></span><br><span class="line">        OracleUser oracleUser = (OracleUser) c1.newInstance();</span><br><span class="line">        <span class="keyword">return</span> oracleUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、原型模式"><a href="#4、原型模式" class="headerlink" title="4、原型模式"></a>4、原型模式</h3><p><strong>原理</strong>：用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象。该模式不用重新初始化对象，而是动态地获取对象运行时的状态</p><p><strong>类图</strong>：</p><p><img src="https://note.youdao.com/yws/api/personal/file/561C0D4AB0E04F4693AAF316CAFC7704?method=download&amp;shareKey=e77ec8be4bafa434a0ff168731b143cf" alt></p><p><strong>深复制与浅复制</strong>：</p><p>浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象</p><p>深复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 浅复制</span></span><br><span class="line"><span class="comment">     * 如果字段是值类型，对该字段执行逐位复制；如果字段是引用类型，则复制引用但不复制引用的对象</span></span><br><span class="line"><span class="comment">     * 因此，原始对象跟它副本都是引用同一个对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Prototype proto = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="keyword">return</span> proto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深复制</span></span><br><span class="line"><span class="comment">     * 所有需要复制的对象都需要实现java.io.Serializable接口。</span></span><br><span class="line"><span class="comment">     * 对象被序列化，然后又被反序列化。反序列化的对象就成了一个深克隆的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/* 写入当前对象的二进制流 */</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 读出二进制流产生的新对象 */</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        <span class="keyword">return</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原型模式的优缺点</strong>：</p><p>优点：原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。</p><p>缺点：原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。</p><h3 id="5、建造者模式（生成器模式）"><a href="#5、建造者模式（生成器模式）" class="headerlink" title="5、建造者模式（生成器模式）"></a>5、建造者模式（生成器模式）</h3><p><strong>原理</strong>：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。所以当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时使用的模式</p><p><strong>类图</strong>：</p><p><img src="https://note.youdao.com/yws/api/personal/file/4934149B8C4D416BB56CB04F70D433BF?method=download&amp;shareKey=abacae4ce0274748ab1cec292304ef88" alt></p><p><strong>抽象建造者（Builder）角色：</strong>给 出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是<strong>建造方法(buildPart1和 buildPart2)</strong>，另一种是<strong>返还结构方法(retrieveResult)</strong>。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，<u>有多少零件，就有多少相应的建造方法</u>。</p><p><strong>具体建造者（ConcreteBuilder）角色：</strong>担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。这个角色要完成的任务包括：1.实现抽象建造者Builder所声明的接口，给出一步一步地完成创建产品实例的操作。2.在建造过程完成后，提供产品的实例。</p><p><strong>导演者（Director）角色：</strong>担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。</p><p><strong>产品（Product）角色：</strong>产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。</p><p><em>一般来说，每有一个产品类，就有一个相应的具体建造者类。这些产品应当有一样数目的零件，而每有一个零件就相应地在所有的建造者角色里有一个建造方法。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品零件建造方法1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建产品的第一个零件</span></span><br><span class="line"> 　　　　product.setPart1(<span class="string">"编号：9527"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品零件建造方法2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建产品的第二个零件</span></span><br><span class="line"> 　　　　product.setPart2(<span class="string">"名称：XXX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品返还方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">retrieveResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导演类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有当前需要使用的建造器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入建造器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder 建造器对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品构造方法，负责调用各个零件建造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildPart1();</span><br><span class="line">        builder.buildPart2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>通过行为型模式，可以更加清晰地划分类与对象的职责，描述类或对象怎样<strong>进行交互和职责分配</strong>。并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h3 id="1、策略模式"><a href="#1、策略模式" class="headerlink" title="1、策略模式"></a>1、策略模式</h3><h3 id="2、模板方法模式"><a href="#2、模板方法模式" class="headerlink" title="2、模板方法模式"></a>2、模板方法模式</h3><h3 id="3、观察者模式"><a href="#3、观察者模式" class="headerlink" title="3、观察者模式"></a>3、观察者模式</h3><h3 id="4、迭代子模式"><a href="#4、迭代子模式" class="headerlink" title="4、迭代子模式"></a>4、迭代子模式</h3><h3 id="5、责任链模式"><a href="#5、责任链模式" class="headerlink" title="5、责任链模式"></a>5、责任链模式</h3><h3 id="6、命令模式"><a href="#6、命令模式" class="headerlink" title="6、命令模式"></a>6、命令模式</h3><h3 id="7、备忘录模式"><a href="#7、备忘录模式" class="headerlink" title="7、备忘录模式"></a>7、备忘录模式</h3><h3 id="8、状态模式"><a href="#8、状态模式" class="headerlink" title="8、状态模式"></a>8、状态模式</h3><h3 id="9、访问者模式"><a href="#9、访问者模式" class="headerlink" title="9、访问者模式"></a>9、访问者模式</h3><h3 id="10、中介者模式"><a href="#10、中介者模式" class="headerlink" title="10、中介者模式"></a>10、中介者模式</h3><h3 id="11、解释器模式"><a href="#11、解释器模式" class="headerlink" title="11、解释器模式"></a>11、解释器模式</h3><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>处理类或对象间的组合。它将以不同的方式影响着程序，允许在补充写代码或自定义代码的情况下创建系统，而且具有重复使用性和应用性能</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p><img src="http://dl.iteye.com/upload/attachment/0083/1187/e28698b9-994e-3fa8-8810-16f30e7cf3e3.jpg" alt></p><h3 id="1、适配器模式"><a href="#1、适配器模式" class="headerlink" title="1、适配器模式"></a>1、适配器模式</h3><h3 id="2、装饰器模式"><a href="#2、装饰器模式" class="headerlink" title="2、装饰器模式"></a>2、装饰器模式</h3><h3 id="3、代理模式"><a href="#3、代理模式" class="headerlink" title="3、代理模式"></a>3、代理模式</h3><h3 id="4、外观模式"><a href="#4、外观模式" class="headerlink" title="4、外观模式"></a>4、外观模式</h3><h3 id="5、桥接模式"><a href="#5、桥接模式" class="headerlink" title="5、桥接模式"></a>5、桥接模式</h3><h3 id="6、组合模式"><a href="#6、组合模式" class="headerlink" title="6、组合模式"></a>6、组合模式</h3><h3 id="7、享元模式"><a href="#7、享元模式" class="headerlink" title="7、享元模式"></a>7、享元模式</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;[TOC]&lt;/p&gt;&lt;h1 id=&quot;一、设计模式的六大原则&quot;&gt;&lt;a href=&quot;#一、设计模式的六大原则&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker的镜像</title>
    <link href="http://yoursite.com/2017/03/07/Docker%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>http://yoursite.com/2017/03/07/Docker的镜像/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-11T03:19:05.353Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><table><thead><tr><th style="text-align:center">子命令分类</th><th style="text-align:center">子命令</th></tr></thead><tbody><tr><td style="text-align:center">Docker环境信息</td><td style="text-align:center">info、version</td></tr><tr><td style="text-align:center">容器生命周期管理</td><td style="text-align:center">create、exec、kill、pause、restart、rm、run、start、stop、unpause</td></tr><tr><td style="text-align:center">镜像仓库命令</td><td style="text-align:center">login、logout、pull、push、search</td></tr><tr><td style="text-align:center">镜像管理</td><td style="text-align:center">build、images、import、load、rmi、save、tag、commit</td></tr><tr><td style="text-align:center">容器运维操作</td><td style="text-align:center">attach、export、inspect、port、ps、rename、status、top、wait、cp、diff、update</td></tr><tr><td style="text-align:center">容器资源管理</td><td style="text-align:center">volume、network</td></tr><tr><td style="text-align:center">系统日志信息</td><td style="text-align:center">events、history、logs</td></tr></tbody></table><h2 id="Docker的镜像"><a href="#Docker的镜像" class="headerlink" title="Docker的镜像"></a>Docker的镜像</h2><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>Docker运行容器前需要本地存在对应的镜像，如果镜像不存在本地，Docker会从镜像仓库下载（默认是Docker Hub 公共注册服务器中的仓库）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure><p>Docker Registry地址：&lt;域名/IP&gt;[:端口号]，默认地址为Docker Hub<br>仓库名：&lt;用户名&gt;/&lt;软件名&gt;。对于Docker Hub，默认为library，也就是官方的镜像。</p><h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//-a 显示包括中间层镜像在内的全部镜像</span><br><span class="line">docker images [-a] [image_name]:[tag]</span><br><span class="line">//filter过滤参数 --filter/-f</span><br><span class="line">docker images -f since=[image_name]  #镜像版本之前的，用before</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>格式化显示</span><br><span class="line">docker images --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span><br></pre></td></tr></table></figure><h4 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>镜像可以是 镜像短ID（去前3个字符以上）、镜像长ID、镜像名或者镜像摘要，(镜像名:Tag)</span><br><span class="line">docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><h4 id="Commit定制镜像"><a href="#Commit定制镜像" class="headerlink" title="Commit定制镜像"></a>Commit定制镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//构建镜像，commit命令，不推荐</span><br><span class="line">//将容器的存储层保存下来成为镜像</span><br><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><h4 id="Dockerfile定制镜像"><a href="#Dockerfile定制镜像" class="headerlink" title="Dockerfile定制镜像"></a>Dockerfile定制镜像</h4><h5 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h5><p>1、FROM指定基础镜像</p><p>2、 RUN执行命令</p><ul><li>shell格式：RUN &lt;命令&gt; ，直接在命令行输入命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><ul><li>exec格式：RUN [“可执行文件”，”参数1”，”参数2”]，类似函数调用</li></ul><p>举个栗子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps='gcc libc6-dev make' \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>RUN命令中使用&amp;&amp;将各个所需命令串联起来，支持Shell类 的行尾添加 \ 的命令换行方式，以及行首#进行注释的格式</p><p>在Dockerfile 文件所在目录执行，构建镜像。RUN指令首先启动一个容器，执行所要求的命令，提交一个新的镜像中，随后删除所用到的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t xx:v3 .</span><br></pre></td></tr></table></figure><p>镜像构建上下文</p><pre><code>在上面的命令中，我们发现在docker build的最后面有一个 .   表示当前目录。但是这不是在指定Dockerfile所在的路径。==因为在默认情况下，如果不指定Dockerfile，会将上下文目录下名为Dockerfile的文件作为Dockerfile。==再举个栗子吧：我们不能COPY ../xx/yyy 或者 COPY /opt/xx/yyy。因为这些路径已经是超出上下文的范围了，我们是将当前目录指定为上下文目录的。（Dockerfile文件名不需要为Dockerfile，也不要求位于上下文目录中，可以用 -f 来指定文件）为什么我们需要上下文这个概念呢？因为docker客户端的命令通过Docker Remote API 和Docker引擎进行交互，一切都是使用远程调用形式在服务端（Docker引擎）完成。所以在我们构建的时候，用户会指定构建镜像上下文的路径。</code></pre><p>3、COPY复制文件</p><h2 id="Docker的容器"><a href="#Docker的容器" class="headerlink" title="Docker的容器"></a>Docker的容器</h2><h4 id="新建、启动容器"><a href="#新建、启动容器" class="headerlink" title="新建、启动容器"></a>新建、启动容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//新建并启动容器</span><br><span class="line">//-i标志保证容器中的STDIN开启，-t分配一个伪tty终端,-d为后台运行，</span><br><span class="line">//-p为指定端口映射，宿主机:容器，/bin/bash启动一个Bash shell</span><br><span class="line">docker run --name yyy(容器名) [-d] -i -t xxxx(镜像名) /bin/bash</span><br><span class="line"></span><br><span class="line">//进入容器</span><br><span class="line">docker exec -it container_name /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// -a 查看全部容器，包括停止和运行，-q 查看容器ID</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//启动已经停止的容器</span><br><span class="line">docker start container_name[或者container_id]</span><br><span class="line">//重启容器</span><br><span class="line">docker restart container_name[或者container_id]</span><br><span class="line">//删除容器</span><br><span class="line">docker rm [-f] </span><br><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure><h4 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>导出容器快照</span><br><span class="line">docker export container_ID &gt; xxx.tar</span><br><span class="line"><span class="meta">#</span>导入容器快照</span><br><span class="line">cat xxx.tar | docker import - xxx/yyy:v1.0</span><br><span class="line">docker import url</span><br></pre></td></tr></table></figure><p>docker load 和 docker import的区别：</p><p>docker load 是导入镜像存储文件到本地镜像库。</p><p>容器快照文件将丢弃所有的历史纪录和元数据信息（仅保存容器当时的快照状态），而镜像存储文件将保存完整纪录，体积也很大。</p><h4 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h4><p>容器的连接系统是除了端口映射外，另一种跟容器中应用交互的方式。该系统会在源和接受容器之间创建一个隧道，接受肉国企可以看到源容器指定的信息。</p><p>使用–link参数使容器之间安全进行交互，–link name:alias，name为要链接的容器的名字，alias是这个链接的别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name db training/postgres</span><br><span class="line">docker run -d -P --name web --link db:db training/webapp</span><br><span class="line"><span class="meta">#</span>用docker ps查看容器的连接</span><br><span class="line">在自定义命名的容器，有db和web，在db容器的names列有db,web/db，表示web容器链接到db容器，web容器被允许访问db容器信息。</span><br><span class="line">上面这个做法，可以避免db容器暴露数据库端口到外部网络上。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>2种方式为容器公开连接信息</span><br><span class="line">第一种：环境变量，用env命令查看web容器的环境变量</span><br><span class="line">docker run --rm --name web2 --link db:db training/webapp env</span><br><span class="line">第二种：更新/etc/hosts文件</span><br></pre></td></tr></table></figure><h2 id="Docker的仓库"><a href="#Docker的仓库" class="headerlink" title="Docker的仓库"></a>Docker的仓库</h2><h4 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>登录，输入用户名、密码、邮箱来完成注册和登录。注册完成后，本地用户目录.dockercfg保存用户的认证信息</span><br><span class="line">docker login </span><br><span class="line"><span class="meta">#</span>-s N：显示评价为N星以上的镜像</span><br><span class="line">docker search [-s N] image_name</span><br><span class="line"><span class="meta">#</span>下载镜像到本地</span><br><span class="line">docker pull</span><br><span class="line">docker push</span><br></pre></td></tr></table></figure><h4 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h4><p>docker-registry是官方提供的工具，可以用于构建私有的镜像仓库。</p><p><strong>从容器运行Registry</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>默认情况下，仓库会被创建在容器的/temp/registry下，-v指定将镜像文件存放在本地的指定路径</span><br><span class="line">docker run -d -p 5000:500 -v /opt/data/registry:/tmp/registry registry</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align:center&quot;&gt;子命令分类&lt;/th&gt;&lt;th style=&quot;text-a
      
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud（四）：熔断器Hystrix</title>
    <link href="http://yoursite.com/2017/03/07/Spring%20Cloud%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%86%94%E6%96%AD%E5%99%A8Hystrix/"/>
    <id>http://yoursite.com/2017/03/07/Spring Cloud（四）：熔断器Hystrix/</id>
    <published>2017-03-07T05:25:24.000Z</published>
    <updated>2019-04-11T03:24:12.593Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --><h2 id="什么是熔断器Hystrix？"><a href="#什么是熔断器Hystrix？" class="headerlink" title="什么是熔断器Hystrix？"></a>什么是熔断器Hystrix？</h2><p>在分布式系统中，服务与服务之间的依赖错综复杂， 一种不可避免的情况就是某些服务会<br>出现故障，导致依赖于它们的其他服务出现远程调度的线程阻塞。Hystrix 是Netflix 公司开<br>源的一个项目，它提供了熔断器功能，能够阻止分布式系统中出现联动故障。Hystrix 是通过<br>隔离服务的访问点阻止联动故障的，并提供了故障的解决方案，从而提高了整个分布式系统<br>的弹性。</p><p>出现问题的场景：由于服务的依赖性，会导致依赖于该故障服务的其他服务也处于线程阻<br>塞状态，最终导致这些服务的线程资源消耗殆尽， 直到不可用，从而导致整个问服务系统都不<br>可用，即雪崩效应。</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li>防止单个服务的故障耗尽整个服务的Servlet 容器（例如Tomcat ）的线程资源。</li><li>快速失败机制，如果某个服务出现了故障，则调用该服务的请求快速失败，而不是线<br>程等待。</li><li>提供回退（ fallback ）方案，在请求发生故障时，提供设定好的回退方案。</li><li>使用熔断机制，防止故障扩散到其他服务。</li><li>提供熔断器的监控组件Hystrix Dashboard，可以实时监控熔断器的状态。</li></ul><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p><img src="https://note.youdao.com/yws/api/personal/file/BE8B3CE6A57649218A457044B47C1460?method=download&amp;shareKey=c3d4b8a099ed8899cd3cd72b0299c54c" alt></p><ol><li><p>创建HystrixCommand或HystrixObservableCommand对象</p></li><li><p>命令行执行（命令行模式）</p><blockquote><ul><li>HystrixCommand实现了execute（）同步执行、queue（）异步执行</li></ul><p><code>R value = command.execute();</code></p><p><code>Future&lt;R&gt; fValue = command.queue();</code></p><ul><li>HystrixObservableCommand()实现了observe（）返回Hot Observable、toObservable（）返回Cold Observable</li></ul><p><code>Observable&lt;R&gt; ohValue = command.observe();</code></p><p><code>Observable&lt;R&gt; ohValue = command.toObservable();</code></p></blockquote></li><li><p>结果是否被缓存</p><p>若当前命令的请求缓存功能是被启用，并且该命令缓存命中，那么缓存的结果会立即以Observable对象的形式返回。</p></li><li><p>断路器是否打开</p><p>在命令结果没有缓存命中时，Hystrix在执行命令前需要检查短路器是否为打开状态：</p><blockquote><ul><li>断路器打开时，Hystrix不执行命令，转接到fallback处理逻辑，跳到第8步。</li><li>断路器关闭时，Hustrix跳到第5步，检查是否有可用资源来执行命令</li></ul></blockquote></li><li><p>线程池/请求队列/信号量是否占满</p><p>如果线程池/请求队列/信号量都占满了，Hystrix不会执行命令，转接到fallback处理逻辑，跳到第8步。</p><p>==注意：==这里的线程池是指每个依赖服务的专有线程池。Hystrix采用了“舱壁模式”来隔离每个依赖的服务</p></li><li><p>HystrixObservableCommand.construct()或HystrixCommand.run()</p><p>Hystrix根据我们编写的方法来决定采取什么的方式去请求依赖服务</p><blockquote><p>HystrixCommand.run()返回一个单一的结果，或者抛出异常</p><p>HystrixObservableCommand.construct()返回一个Observable对象来发射多个结果或者通过onError发送错误通知</p></blockquote></li><li><p>计算断路器的健康度</p><p>Hystrix会将“成功”、“失败”、“拒绝”、“超时”等信息报告给断路器，断路器维护一组计数器来统计这些数据。</p></li><li><p>fallback处理（==服务降级==）</p><p>需要实现一个通用的响应结果，并且该结果的处理逻辑是从缓存或者根据一些静态逻辑来获取，而不是依赖网络请求获取。（也可以包含网络请求，该请求要包装在HystrixCommand或HystrixObservableCommand中，从而形成了级联的降级策略，最终结果还是一个稳定的返回结果的处理逻辑）</p></li><li><p>返回成功的响应</p></li></ol><h4 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h4><p>优势点：</p><ul><li>应用自身得到完全保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的其余部分</li><li>可以有效降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响应用其他的请求。</li><li>依赖的服务从失效恢复正常后，它的线程池会被清理并能够马上恢复健康的服务。</li><li>依赖的服务出现配置错误的时候，线程池会快速反映出问题</li><li>每个专有线程池提供内置的并发实现</li></ul><h4 id="Hystrix接口和注解"><a href="#Hystrix接口和注解" class="headerlink" title="Hystrix接口和注解"></a>Hystrix接口和注解</h4><h4 id="Hystrix-DashBoard"><a href="#Hystrix-DashBoard" class="headerlink" title="Hystrix DashBoard"></a>Hystrix DashBoard</h4><p>提供了数据监控和友好的图形化展示界面</p><p><img src="https://note.youdao.com/yws/api/personal/file/5325550E788F43E19E3095000725B73B?method=download&amp;shareKey=119adac5a686d3159617a8723df26aac" alt></p><p>支持三种不同的监控方式：</p><ul><li>默认的集群监控：通过URL <a href="http://turbine-hostname:port/turbine.stream开启，实现对默认集群的监控" target="_blank" rel="noopener">http://turbine-hostname:port/turbine.stream开启，实现对默认集群的监控</a></li><li>指定的集群监控：通过URL <a href="http://turbine-hostname:port/turbine.stream?cluster=[clusterName]开启，实现对clusterName集群的监控" target="_blank" rel="noopener">http://turbine-hostname:port/turbine.stream?cluster=[clusterName]开启，实现对clusterName集群的监控</a></li><li>单体应用的监控：通过URL <a href="http://turbine-hostname:port/hystrix.stream开启，实现对具体单个服务实例的监控" target="_blank" rel="noopener">http://turbine-hostname:port/hystrix.stream开启，实现对具体单个服务实例的监控</a></li></ul><p>如果是监控多个集群应用，方法有点不一样，主要是消费者的配置文件要加点东西。跟着我看一下吧</p><p>turbine配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line"><span class="attr">  aggregator:</span></span><br><span class="line"><span class="attr">    cluster-config:</span> <span class="string">mycluster</span>   <span class="comment">#自定义集群名称</span></span><br><span class="line"><span class="attr">  app-config:</span> <span class="string">eureka-feign-client</span>    <span class="comment">#,eureka-ribbon-client</span></span><br><span class="line"><span class="attr">  cluster-name-expression:</span> <span class="string">metadata['cluster']</span>   <span class="comment">#固定的</span></span><br><span class="line"><span class="attr">  combine-host-port:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  instanceUrlSuffix:</span> <span class="string">/hystrix.stream</span></span><br></pre></td></tr></table></figure><p>消费者的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">metadata-map:</span></span><br><span class="line"><span class="attr">cluster:</span> <span class="string">mycluster</span></span><br></pre></td></tr></table></figure><h4 id="Turbine监控"><a href="#Turbine监控" class="headerlink" title="Turbine监控"></a>Turbine监控</h4><p>用这个Turbine的想法很简单，一个词叫做聚合。把多实例放在一起来统计、管理、监控</p><p><img src="https://note.youdao.com/yws/api/personal/file/A9865FFDCAFC42F0A085B3AF1BC471F8?method=download&amp;shareKey=457b23f146ae621a6232468c56e360d0" alt></p><ul><li>pom.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>在启动类上面加注解@EnableTurbine开启Turbine</p></li><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line"><span class="attr">  aggregator:</span></span><br><span class="line"><span class="attr">    cluster-config:</span> <span class="string">default</span> </span><br><span class="line"><span class="attr">  app-config:</span> <span class="string">eureka-ribbon-client,eureka-feign-client</span></span><br><span class="line"><span class="attr">  cluster-name-expression:</span> <span class="string">new</span> <span class="string">String("default")</span></span><br><span class="line"><span class="attr">  combine-host-port:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  instanceUrlSuffix:</span> <span class="string">/hystrix.stream</span></span><br></pre></td></tr></table></figure><p>aggregator.cluster-config：指定聚合哪些集群，多个使用”,”分割，默认为default。可使用http://…/turbine.stream?cluster={clusterConfig之一}访问</p><p>app-config：需要收集监控信息的服务名</p><p>cluster-name-expression：指定集群名称为default，如果为default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default</p><p>combine-host-port：设置为true，可以让一台主机上的服务通过主机名和端口号组合来区分。默认是通过host来区分不同的服务的。</p></li><li><p>启动Turbine</p><p>重启工程一切正常，打开 <a href="http://localhost:port/hystrix" target="_blank" rel="noopener">http://localhost:port/hystrix</a> 然后输入监控地址，因为前面我们使用的是default cluster所以这里输入：<a href="http://localhost:port/turbine.stream" target="_blank" rel="noopener">http://localhost:port/turbine.stream</a></p><p>点击 Monitor Stream 按钮后，需要访问 <a href="http://localhost:8764/testRibbon?name=rocye" target="_blank" rel="noopener">http://localhost:8764/testRibbon?name=rocye</a> 和 <a href="http://localhost:port/testRibbon?name=rocye" target="_blank" rel="noopener">http://localhost:port/testRibbon?name=rocye</a> 可以多刷新几次，可以看到如下效果</p></li><li><p>仪表盘参数详细说明</p><p><img src="https://note.youdao.com/yws/api/personal/file/C73E4EBB5727418E882320996021F3CB?method=download&amp;shareKey=5208d35b9af6bb5075a219aa664be07e" alt></p></li></ul><h4 id="Turbine-Stream"><a href="#Turbine-Stream" class="headerlink" title="Turbine Stream"></a>Turbine Stream</h4><h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><ol><li>Unable to connect to Command Metric Stream</li></ol><p>解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DashBoardConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">servletRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Turbine404问题</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; com.netflix.turbine.monitor.instance.InstanceMonitor$MisconfiguredHostException:</span><br><span class="line">&gt; [&#123;&quot;timestamp&quot;:&quot;2018-06-28T08:01:38.908+0000&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;message&quot;:&quot;No message available&quot;,&quot;path&quot;:&quot;/actuator/hystrix.stream&quot;&#125;]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>解决办法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line">  <span class="comment">#aggregator:</span></span><br><span class="line">    <span class="comment">#cluster-config: default</span></span><br><span class="line"><span class="attr">  app-config:</span> <span class="string">eureka-feign-client</span>    <span class="comment">#,eureka-ribbon-client</span></span><br><span class="line"><span class="attr">  cluster-name-expression:</span> <span class="string">new</span> <span class="string">String("default")</span> <span class="comment">#metadata['cluster']</span></span><br><span class="line"><span class="attr">  combine-host-port:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  instanceUrlSuffix:</span> <span class="string">/hystrix.stream</span>   <span class="comment">#一定要加这个</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 18 2019 11:27:06 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;什么是熔断器Hystrix？&quot;&gt;&lt;a href=&quot;#什么是熔断器Hystrix？&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://yoursite.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
  </entry>
  
</feed>
